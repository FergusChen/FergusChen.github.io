<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[排序算法总结 java实现]]></title>
      <url>https://FergusChen.github.io/2016/08/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-java%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>不同的排序算法源于不同的思想。虽然目标是一样的，却有不同的效率，各自的稳定性、是否是原址排序也是有所不同。这里做一个总结，并且附上java实现的代码。具体如下：<a id="more"></a>  </p>
<ul>
<li>基本概念</li>
<li>插入排序</li>
<li>冒泡排序</li>
<li>选择排序</li>
<li>归并排序</li>
<li>堆排序</li>
<li>快速排序</li>
</ul>
<hr>
<blockquote>
<p>完整代码（包括测试用例）: (<a href="https://github.com/FergusChen/AlgoCode" target="_blank" rel="external">https://github.com/FergusChen/AlgoCode</a>)<br>包路径：main.sort  </p>
</blockquote>
<p>先说一些概念型的东西，用于描述排序算法：<br><strong>原址排序</strong>：直接在原数组中排序，只需要常数个额外空间。<br><strong>稳定排序</strong>：如果一个排序算法是稳定的，则序列中<strong>相同的元素</strong>原来有怎样的前后次序，排序后仍然是这样的前后次序。具体来说，对于序列<code>[1,3,5,3,4]</code>， 排序后序列为<code>[1,3,3,4,5]</code>，其中，原来在前面的<code>3</code>仍然在前面，保证两个<code>3</code>的前后次序，这样的排序算法就是稳定的。  </p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>听到插入排序就想起来左手一副扑克牌，扑克牌的左半部分是已经排好序的，然后逐个抽取右半部分的牌，插入到左半部分的合适位置，直到整副牌都是排好序的。  </p>
<p>插入排序就是这样的思想。初始化时左半部分只有<code>1</code>个元素，当然是排好序的啦。然后从右半部分的第<code>1</code>个元素开始，与左半部分已排好序的元素逐个比较，直到找到合适位置（插入后仍使左半部分有序），将该元素插入到此位置就可。  </p>
<p>当然，插入的时候就涉及到<code>元素的右移</code>，即把待插入的位置右边的元素(<em>直到待插入的元素</em>)<strong>逐个右移</strong>，腾出<code>1</code>个元素空间，以存放待插入的元素。特别是当原数组是倒序的，则会有<code>(n-1)!</code>次元素右移，这样的话效率就会比较低。</p>
<p>由上可知，插入排序是<strong>原址排序</strong>，其最坏运行时间是<code>O(n^2)</code>。并且插入排序是<strong>稳定的</strong>，因为相等的元素并不右移，所以元素插入后仍然保证前后次序。当待排序数组元素较少，插入排序还是很好的选择。  </p>
<p>下面以整型数组为例来实现插入排序，只是演示排序思想。对于自定义对象等的排序，常常可以实现comparable接口，从compareTo方法比较，思想都是一样的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * ------插入排序------</div><div class="line"> * <span class="doctag">@param</span> array 待排序数组</div><div class="line"> * test: (null), （1个元素的数组），（空数组），(5个无序整数数组)，（6个有序整数数组）</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">        <span class="keyword">int</span> curData = array[i];</div><div class="line">        <span class="keyword">int</span> posForInsert = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (array[j] &gt; curData) &#123;</div><div class="line">                array[j + <span class="number">1</span>] = array[j];</div><div class="line">                posForInsert--;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>; <span class="comment">//0到i-1位置的元素都已经有序，所有大于curData的元素右移之后就可以结束</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        array[posForInsert] = curData;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序的名字就很形象：就好像从水底开始，相邻两个气泡互相比较，如果下面的比上面的大，就把两个气泡交换，直到最终把整个序列中最大的气泡换到顶部。接下来从下面开始，一步步把次大的气泡换到顶部…… 直到最后，就是一个升序的序列。</p>
<p>冒泡排序也是一种原址排序算法。冒泡排序是稳定的，因为冒泡排序是相邻两个元素交换次序，就算两个元素相等而且判断的条件是<code>if(array[j] &gt;= array[j+1])</code>，那么该相同元素也会交换两次(<em>动手试试就知道了</em>)。但是通常比较时“<code>&gt;</code>”的时候再交换位置。 冒泡排序是时间复杂度是<code>O(n^2)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 冒泡排序</div><div class="line"> * <span class="doctag">@param</span> array 待排序数组</div><div class="line"> * test: (null), （1个元素的数组），（空数组），(5个无序整数数组)，（6个有序整数数组）</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">int</span> temp = array[j];</div><div class="line">                array[j] = array[j + <span class="number">1</span>];</div><div class="line">                array[j + <span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序的思想也很简单，就是从序列中选出最小的元素，与序列第1个元素交换位置，然后从剩余元素中选出最小的，与序列第2个元素交换位置……直到序列就剩1个元素了，即是一个排好序的序列。<br>选择排序也是原址排序，但选择排序是不稳定的。这里可以举个例子说明，如序列[3,6,5,3,1]，在第一趟选择将第1个<code>3</code>和结尾的<code>1</code>交换位置，这样就破坏了两个<code>3</code>的前后次序。选择排序的时间复杂度是<code>O(n^2)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 选择排序</div><div class="line"> * <span class="doctag">@param</span> array 待排序数组</div><div class="line"> * test: (null), （1个元素的数组），（空数组），(5个无序整数数组)，（6个无序整数数组）</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</div><div class="line">        <span class="keyword">int</span> minIndex = i;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; array.length; j++)&#123;</div><div class="line">            <span class="keyword">if</span>(array[j] &lt; array[minIndex])&#123;</div><div class="line">                minIndex = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> temp = array[i];</div><div class="line">        array[i] = array[minIndex];</div><div class="line">        array[minIndex] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序的思想是“<strong>分治、合并</strong>”，其关键步骤是把两个有序的序列<strong>合并</strong>成1个有序序列。那么，有序的序列怎么形成呢？归并排序采用<strong>分治</strong>的策略，先对序列进行划分（递归），直到划分子序列只有1个元素，1个元素的序列当然是有序的啦，然后就可以将两个只含有1个元素的序列合并成1个含有两个元素的有序序列。总之，就是先划分，再回溯合并，这整个过程就是一个递归的过程。</p>
<p>归并排序的时间复杂度是<code>O(nlgn)</code>，是一种稳定排序。归并排序需要将元素复制到临时数组，临时数组的长度为<code>high - low + 1</code>，因此，归并排序并不是原址排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 归并排序</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array 待排序数组</div><div class="line"> * <span class="doctag">@param</span> low 待排序数组序列的最低位置</div><div class="line"> * <span class="doctag">@param</span> high 待排序数组序列的最高位置</div><div class="line"> * test: (null), （1个元素的数组），（空数组），(5个无序整数数组)，（6个无序整数数组）</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line">        mergeSort(array, low, mid);</div><div class="line">        mergeSort(array, mid + <span class="number">1</span>, high);</div><div class="line">        merge(array, low, mid, high);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 归并过程</div><div class="line"> * <span class="doctag">@param</span> array 待合并的数组</div><div class="line"> * <span class="doctag">@param</span> low 待合并数组序列的最低位置</div><div class="line"> * <span class="doctag">@param</span> mid 待合并数组序列中划分两个有序序列的位置</div><div class="line"> * <span class="doctag">@param</span> high 待合并数组序列的最高位置</div><div class="line"> * 将array中 low到high的元素归并到有序序列，其中，low到mid的序列是有序的，mid+1到high的序列是有序的。</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span>[] tempArr = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> i = low; <span class="comment">//i指向已排好序的左序列</span></div><div class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;  <span class="comment">//j指向已排好序的右序列</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//合并到新数组的指针</span></div><div class="line">        </div><div class="line">    <span class="comment">//合并过程</span></div><div class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= high)&#123;</div><div class="line">        <span class="keyword">if</span>(array[i] &lt; array[j])&#123;</div><div class="line">            tempArr[k++] = array[i++];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            tempArr[k++] = array[j++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//若左边有序序列有剩余元素，将剩余元素合并到tempArr中</span></div><div class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</div><div class="line">        tempArr[k++] = array[i++];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//若右边有序序列有剩余元素，将剩余元素合并到tempArr中</span></div><div class="line">    <span class="keyword">while</span> (j &lt;= high)&#123;</div><div class="line">        tempArr[k++] = array[j++];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//用合并后的有序序列覆盖原数组中的左右两部分序列</span></div><div class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; tempArr.length; k++)&#123;</div><div class="line">        array[k+low] = tempArr[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序涉及到一种比较有意思的数据结构——<strong>堆</strong>，对于其性质，可以回顾《算法导论》。简单来说，堆就是用数组实现的一颗近似的完全二叉树。最大堆可以保证每一个父结点都大于或等于其子结点。这样最大堆的根节点就是该数组的最大值。 </p>
<p>堆排序使用最大堆，需要首先建堆，并且在交换根结点和最后一个结点之后，反复对堆维护。听起来很麻烦，但是因为每次维护堆的时间复杂度是<code>O(lgn)</code>，建堆的时间复杂度是<code>O(nlgn)</code>,则堆排序的时间复杂度仍然是<code>O(nlgn)</code>。堆排序是原址排序，但堆排序是不稳定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 堆排序</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array 待排序的堆</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    buildMaxHeap(array);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</div><div class="line">        exchangeElements(array, <span class="number">0</span>, i);</div><div class="line">        maxHeapify(array, i, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 维护堆</div><div class="line"> * 在这个堆中，只有index位置的元素违背了最大堆的性质，调整该元素的位置，使index位置元素为结点为根的堆仍然是最大堆。</div><div class="line"> * 思想：index位置的元素与其左右孩子比较，将三个元素中的最大值与index位置的元素交换，然后递归地向下调整</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array    待维护的堆</div><div class="line"> * <span class="doctag">@param</span> heapSize 堆的元素个数</div><div class="line"> * <span class="doctag">@param</span> index    带调整的元素位置</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> heapSize, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> right = index * <span class="number">2</span> + <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> largest = index;</div><div class="line">    <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; array[left] &gt; array[index]) &#123;</div><div class="line">        largest = left;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123;</div><div class="line">        largest = right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (largest != index) &#123;</div><div class="line">        exchangeElements(array, index, largest);</div><div class="line">        maxHeapify(array, heapSize, largest);<span class="comment">//递归地向下维护堆</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 新建最大堆</div><div class="line"> * <span class="doctag">@param</span> array 待建堆的数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (array.length - <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        maxHeapify(array, array.length, i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序也是使用“<strong>分治</strong>”的思想，但与归并排序不同的是，快速排序在分治的过程中进行处理次序，具体来说，对于数组<code>A[low ... high]</code>，被划分为两个（可能为空）的子数组<code>A[low ... p-1]</code>和<code>A[p+1 ... high]</code>，使得<code>A[low ... p-1]</code>的元素都小于或等于<code>A[p]</code>，<code>A[p+1 ... high]</code>的元素都大于<code>A[p]</code>。 然后再递归地划分<code>A[low ... p-1]</code>和<code>A[p+1 ... high]</code>。当左右子序列划分都递归到1个元素时，整个序列都是有序的啦。  </p>
<p>快速排序的平均时间复杂度为<code>O(nlgn)</code>，最坏时间复杂度是<code>O(n^2)</code>。快速排序的实际性能是几个<code>O(nlgn)</code>中最好的，而且还是原址排序。但是快速排序并不是稳定的排序算法。因为会涉及到元素与主元的交换。举个例子，对于序列[2,3,4,6,6,7,9,5]，以<code>5</code>为主元，当划分之后，元素<code>5</code>需要与第1个<code>6</code>交换位置，这样，就打破了两个<code>6</code>的前后次序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 快速排序</div><div class="line"> * <span class="doctag">@param</span> array 带排序的数组</div><div class="line"> * <span class="doctag">@param</span> low 带排序数组的最低位置</div><div class="line"> * <span class="doctag">@param</span> high 带排序的数组的最高位置</div><div class="line"> * test: (null), （1个元素的数组），（空数组），(5个无序整数数组)，（6个无序整数数组）</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">int</span> p = randomPartition (array, low, high);</div><div class="line">        quickSort(array, low, p - <span class="number">1</span>);</div><div class="line">        quickSort(array, p + <span class="number">1</span>, high);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 随机选取数组中的一个数进行划分</div><div class="line"> * <span class="doctag">@param</span> array 带划分的数组序列</div><div class="line"> * <span class="doctag">@param</span> low 带划分数组序列的最低位置</div><div class="line"> * <span class="doctag">@param</span> high 带划分数组序列的最高位置</div><div class="line"> * <span class="doctag">@return</span> int 返回最后划分后，主元的位置    * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)(low + Math.random()*(high - low + <span class="number">1</span>)); <span class="comment">//产生low到high之间的随机数</span></div><div class="line">    <span class="keyword">int</span> temp = array[high];</div><div class="line">    array[high] = array[i];</div><div class="line">    array[i] = temp;</div><div class="line">    <span class="keyword">return</span> partition(array, low, high);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 划分数组</div><div class="line"> * 将array中low 到 high序列划分为两部分，并返回划分元的位置</div><div class="line"> * <span class="doctag">@param</span> array 带划分的数组序列</div><div class="line"> * <span class="doctag">@param</span> low 带划分数组序列的最低位置</div><div class="line"> * <span class="doctag">@param</span> high 带划分数组序列的最高位置</div><div class="line"> * <span class="doctag">@return</span> int 返回最后划分后，主元的位置</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> key = array[high]; <span class="comment">//主元，即用于划分的元素</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> i = low - <span class="number">1</span>; <span class="comment">//i指向 小于key的序列的尾部</span></div><div class="line">    <span class="comment">//j来遍历整个序列，将小于key的元素放到i的左边</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = low; j &lt; high; j++) &#123;</div><div class="line">        <span class="keyword">if</span> (array[j] &lt;= key) <span class="comment">//不仅是小于key，连等于key的元素也交换，以保证划分过程是原址重排</span></div><div class="line">            i++;</div><div class="line">            <span class="comment">//如果i == j 就无需交换了。</span></div><div class="line">            <span class="keyword">if</span>(i != j) &#123;</div><div class="line">                <span class="keyword">int</span> temp = array[i];</div><div class="line">                array[i] = array[j];</div><div class="line">                array[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//此时，i指向小于key的序列的尾部，则将key与i+1的元素交换，就将整个序列划分为A、B两个部分，其中A：小于或等于key的元素，B：大于key的元素。</span></div><div class="line">    <span class="keyword">int</span> temp = array[i + <span class="number">1</span>];</div><div class="line">    array[i + <span class="number">1</span>] = array[high];</div><div class="line">    array[high] = temp;</div><div class="line">    <span class="comment">//返回用于划分的主元的位置。</span></div><div class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[单链表算法的java实现]]></title>
      <url>https://FergusChen.github.io/2016/08/25/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E7%9A%84java%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>单链表的数据结构非常简单，但是基于单链表的一些算法却特别有意思。这里对各个算法的思路、要点、java实现、测试做一个简单的总结，具体如下：<br><a id="more"></a>  </p>
<ul>
<li>单链表的倒序输出</li>
<li>查到单链表倒数第k个元素</li>
<li>获取单链表的中间元素</li>
<li>两个有序单链表合并</li>
<li>判断两个单链表是否相交</li>
<li>获取两个单链表相交的结点</li>
<li>判断单链表是否有环</li>
<li>判断有环单链表中，环的长度</li>
<li>获取单链表中，环的起始结点</li>
<li>删除单链表中指定结点  </li>
</ul>
<hr>
<blockquote>
<p>完整代码（包括测试用例）: (<a href="https://github.com/FergusChen/AlgoCode" target="_blank" rel="external">https://github.com/FergusChen/AlgoCode</a>)<br>包路径：main.linklist</p>
</blockquote>
<h4 id="单链表的数据结构"><a href="#单链表的数据结构" class="headerlink" title="单链表的数据结构"></a>单链表的数据结构</h4><p>首先，定义单链表的数据结构。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data; <span class="comment">//数据域</span></div><div class="line">    <span class="keyword">public</span> Node next; <span class="comment">//指针域</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="单链表的倒序输出"><a href="#单链表的倒序输出" class="headerlink" title="单链表的倒序输出"></a>单链表的倒序输出</h4><p>单链表的倒序输出即从链表表尾逐个输出到表头。因为单链表的指针域是单向的，所以要找到表尾的话，需要遍历整个链表。<br>这个算法可以有两种实现：1、迭代实现，2、递归实现。  </p>
<h5 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h5><p>迭代实现关键是考虑倒序输出正好符合栈的先进后出的特点——先遍历到的元素最后输出。这样，可以遍历一遍，将数据存储在栈中，然后由栈逐个pop即可。下面是用迭代实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* -------单链表的倒序输出-------</div><div class="line">* test (null), (d1)</div><div class="line">* <span class="doctag">@param</span> head 待倒序输出的链表</div><div class="line">*</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListReversingly_Iterattively</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; nodes = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">        Node pNode = head;</div><div class="line">    <span class="keyword">while</span> (pNode != <span class="keyword">null</span>) &#123;</div><div class="line">        nodes.push(pNode.data);</div><div class="line">        pNode = pNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!nodes.isEmpty()) &#123;</div><div class="line">        System.out.print(nodes.pop() + <span class="string">", "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><p>递归实现即递归地往下找，直到找到最后一个元素，再回溯输出即可。但是，递归实现有个很大的缺陷，就是<strong>当链表元素特别多的时候，递归层次太深，容易造成栈溢出。</strong> 。下面是递归实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* -------单向链表的倒序输出-------</div><div class="line">* <span class="doctag">@param</span> head 待倒序输出的链表</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListReversingly_Recursively</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</div><div class="line">            printListReversingly_Recursively(head.next);</div><div class="line">        &#125;</div><div class="line">        System.out.print(head.data + <span class="string">", "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="查找单链表倒数第k个元素"><a href="#查找单链表倒数第k个元素" class="headerlink" title="查找单链表倒数第k个元素"></a>查找单链表倒数第k个元素</h4><p>查找单链表中倒数第k个元素，仍然有两种实现：1、通过获取链表的长度实现。2、通过两个指针实现。</p>
<h5 id="通过获取链表的长度的实现"><a href="#通过获取链表的长度的实现" class="headerlink" title="通过获取链表的长度的实现"></a>通过获取链表的长度的实现</h5><p>第1次遍历，得到链表长度 length。然后第2次遍历，找到第length-k个元素就是了。这种方法效率较低。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 查找单链表倒数第k个元素</div><div class="line"> * test: (null, 2), (p1, 2), (p1, 200), (p1, 0)</div><div class="line"> * <span class="doctag">@param</span> head 待查找的链表</div><div class="line"> * <span class="doctag">@param</span> k 倒数第k个元素</div><div class="line"> * <span class="doctag">@return</span> Node 返回倒数第k个结点。若k=0或链表为null，则返回null，若k大于链表长度，则抛RuntimeException异常</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getReKthNode1</span><span class="params">(Node head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">    Node cur = head;</div><div class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">        cur = cur.next;</div><div class="line">        ++length;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这里做一步异常处理</span></div><div class="line">    <span class="keyword">if</span> (k &gt; length) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"exceed length of linklist"</span>);</div><div class="line">    &#125;</div><div class="line">    cur = head;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - k; i++) &#123;</div><div class="line">        cur = cur.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cur;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="通过两个指针实现"><a href="#通过两个指针实现" class="headerlink" title="通过两个指针实现"></a>通过两个指针实现</h5><p>如果不允许遍历整个链表，或者要提高效率，就采用这种思路：</p>
<ul>
<li>定义两个指针，pFront先指向第k个元素，pBack指向链表的head</li>
<li>两个指针同时移动遍历，当pFront遍历到链表尾部之后，pBack正好是指向倒数第k个元素。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 查到单链表倒数第k个元素</div><div class="line"> * test: (null, 2), (p1, 2), (p1, 200), (p1, 0)</div><div class="line"> * <span class="doctag">@param</span> head 待查找的结点</div><div class="line"> * <span class="doctag">@param</span> k 倒数第k个元素</div><div class="line"> * <span class="doctag">@return</span> Node 返回倒数第k个结点 ， 若k=0或链表为null，则返回null，若k大于链表长度，则抛RuntimeException异常</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getReKthNode2</span><span class="params">(Node head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    Node pFront = head; </div><div class="line">    Node pBack = head;</div><div class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; pFront != <span class="keyword">null</span>) &#123; <span class="comment">//从1开始数第k个数。</span></div><div class="line">        pFront = pFront.next;</div><div class="line">        --k;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (pFront == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"exceed length of linklist"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (pFront.next != <span class="keyword">null</span>) &#123;</div><div class="line">        pBack = pBack.next;</div><div class="line">        pFront = pFront.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pBack;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="获取单链表的中间元素"><a href="#获取单链表的中间元素" class="headerlink" title="获取单链表的中间元素"></a>获取单链表的中间元素</h4><p>思路：仍然是两个指针，只是pFront一次走2步，pBack一次走1步。直到pFront走到最后一个结点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取单链表的中间元素。</div><div class="line"> * test： （null）, (奇数个)， （偶数个）， （1个元素）</div><div class="line"> * <span class="doctag">@param</span> head 待查找的链表</div><div class="line"> * <span class="doctag">@return</span> Node 链表的中间结点。 若链表为null，则返回null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getMiddleNode</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</div><div class="line"></div><div class="line">    Node pFront = head;</div><div class="line">    Node pBack = head;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!(pFront.next == <span class="keyword">null</span> || pFront.next.next == <span class="keyword">null</span>)) &#123;</div><div class="line">        pFront = pFront.next.next;</div><div class="line">        pBack = pBack.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pBack;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="两个有序单链表合并"><a href="#两个有序单链表合并" class="headerlink" title="两个有序单链表合并"></a>两个有序单链表合并</h4><p>两个单链表head1和head2都各自有序，要求将其合并，得到的结果依然有序。。此问题仍然有两种实现：1、归并排序的思想合并； 2、递归合并</p>
<h5 id="归并排序的思想合并"><a href="#归并排序的思想合并" class="headerlink" title="归并排序的思想合并"></a>归并排序的思想合并</h5><p><strong>思想</strong>：用归并排序merge方法的思想。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 两个有序单链表合并</div><div class="line"> * test： (null, null), (null, head2), (head1, null), (head1,head2) </div><div class="line"> * <span class="doctag">@param</span> head1 第1个有序链表</div><div class="line"> * <span class="doctag">@param</span> head2 第2个有序链表</div><div class="line"> * <span class="doctag">@return</span> Node 归并之后的结果链表 若两个链表都为null，则返回null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">mergeSortedLinklist1</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> head2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (head2 == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> head1;</div><div class="line">    &#125;</div><div class="line">    Node mergeHead = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (head1.data &lt;= head2.data) &#123;</div><div class="line">        mergeHead = head1;</div><div class="line">        head1 = head1.next;</div><div class="line">        mergeHead.next = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mergeHead = head2;</div><div class="line">        head2 = head2.next;  <span class="comment">//注意链表的指针指向，这里的顺序不能错了。只有head指向下一个元素之后，mergeHead的next才能断开</span></div><div class="line">        mergeHead.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    Node mergeCur = mergeHead;</div><div class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (head1.data &lt;= head2.data) &#123;</div><div class="line">            mergeCur.next = head1;</div><div class="line">            head1 = head1.next;</div><div class="line">            mergeCur = mergeCur.next;</div><div class="line">            mergeCur.next = <span class="keyword">null</span>; <span class="comment">//使merge结果与原head1后面的元素断开。</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mergeCur.next = head2;</div><div class="line">            head2 = head2.next;</div><div class="line">            mergeCur = mergeCur.next;</div><div class="line">            mergeCur.next = <span class="keyword">null</span>; <span class="comment">//使merge结果与原head2后面的元素断开。</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (head1 != <span class="keyword">null</span>) &#123;</div><div class="line">        mergeCur.next = head1;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head2 != <span class="keyword">null</span>) &#123;</div><div class="line">        mergeCur.next = head2;</div><div class="line">    &#125;</div><div class="line">        <span class="keyword">return</span> mergeHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="递归合并"><a href="#递归合并" class="headerlink" title="递归合并"></a>递归合并</h5><p>用递归的方法代码更简洁，也可读性也很强。但是，两个链表比较长的时候，递归层次也可能会很深，结果造成<strong>栈溢出</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 两个有序单链表合并</div><div class="line"> * <span class="doctag">@param</span> head1 第1个有序链表</div><div class="line"> * <span class="doctag">@param</span> head2 第2个有序链表</div><div class="line"> * <span class="doctag">@return</span> Node 归并之后的结果链表 ，若两个链表都为null，则返回null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">mergeSortedLinklist2</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> head2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (head2 == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> head1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Node mergeHead = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (head1.data &lt;= head2.data) &#123;</div><div class="line">        mergeHead = head1;</div><div class="line">        mergeHead.next = mergeSortedLinklist2(head1.next, head2);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mergeHead = head2;</div><div class="line">        mergeHead.next = mergeSortedLinklist2(head1, head2.next);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mergeHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="判断两个单链表是否相交"><a href="#判断两个单链表是否相交" class="headerlink" title="判断两个单链表是否相交"></a>判断两个单链表是否相交</h4><p>如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的。相当于“Y”字型的两个链表。<br><strong>思路</strong>：只需要判断两个链表的最后一个节点是否相同即可。这样，只需要比较一次，但两个链表都遍历到尾部，时间复杂度为O(len1+len2)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * -----判断两个单链表是否相交------</div><div class="line"> * test: (null, null), (null, head2),(head1, null), (head1和head2相交), (head1和head2不相交)</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> head1 链表1</div><div class="line"> * <span class="doctag">@param</span> head2 链表2</div><div class="line"> * <span class="doctag">@return</span> boolean。 true：两个链表相交； false：两个链表不相交</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLinkListIntersect</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    Node tail1 = head1;</div><div class="line">    Node tail2 = head2;</div><div class="line">    <span class="keyword">while</span> (tail1.next != <span class="keyword">null</span>) &#123;</div><div class="line">        tail1 = tail1.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (tail2.next != <span class="keyword">null</span>) &#123;</div><div class="line">        tail2 = tail2.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> tail1 == tail2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="获取两个单链表相交的结点"><a href="#获取两个单链表相交的结点" class="headerlink" title="获取两个单链表相交的结点"></a>获取两个单链表相交的结点</h4><p>若两个链表相交，则获取相交处的结点。 即“Y”的交点<br><strong>思路</strong>：如果有交点，则两个链表从交点到尾部一定是相同的元素，而且这段距离小于或等于最短的链表。</p>
<ul>
<li>则可以定义两个指针pFront和pBack，pBack指向较短链表的首部，pFront指向较长链表的lenLong- lenShort位置</li>
<li>两个指针同时移动，直到找到相同结点。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取两个单链表相交的结点</div><div class="line"> * test:(null, null), (null, head2),(head1, null), (head1和head2相交), (head1和head2不相交)</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> head1 链表1</div><div class="line"> * <span class="doctag">@param</span> head2 链表2</div><div class="line"> * <span class="doctag">@return</span> Node 返回两个链表相交的结点。若没有相交，则返回null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getCommonNode</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> len1 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> len2 = <span class="number">1</span>;</div><div class="line">    Node tail1 = head1;</div><div class="line">    Node tail2 = head2;</div><div class="line">    <span class="keyword">while</span> (tail1.next != <span class="keyword">null</span>) &#123;</div><div class="line">        tail1 = tail1.next;</div><div class="line">        ++len1;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (tail2.next != <span class="keyword">null</span>) &#123;</div><div class="line">        tail2 = tail2.next;</div><div class="line">        ++len2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (tail1 != tail2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//不相交</span></div><div class="line">    &#125;</div><div class="line">    Node pFront = <span class="keyword">null</span>;</div><div class="line">    Node pBack = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> distance = <span class="number">0</span>;</div><div class="line">    <span class="comment">//确定head1和heda2哪个比较长，pBack指向短的链表表头</span></div><div class="line">    <span class="keyword">if</span> (len1 &lt;= len2) &#123;</div><div class="line">        pBack = head1;</div><div class="line">        pFront = head2;</div><div class="line">        distance = len2 - len1;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        pBack = head2;</div><div class="line">        pFront = head1;</div><div class="line">        distance = len1 - len2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//让pFront指向lenLong-lenShort的位置</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; distance; i++) &#123;</div><div class="line">        pFront = pFront.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//两个指针同时向链表尾部移动，直到找到交点。</span></div><div class="line">    <span class="keyword">while</span> (pBack != pFront) &#123;</div><div class="line">        pBack = pBack.next;</div><div class="line">        pFront = pFront.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pFront;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="判断单链表是否有环"><a href="#判断单链表是否有环" class="headerlink" title="判断单链表是否有环"></a>判断单链表是否有环</h4><p>如果链表有环，单用一个指针是永远无法遍历到尾部的。那么，判断是否有环的思路，仍然是<strong>两个指针</strong>。<br><strong>思想</strong>：</p>
<ul>
<li>定义两个指针都指向head</li>
<li>一个指针一次走两步，另一个指针一次走一步。</li>
<li>如果两个指针指到了同一个元素，证明有环。<br>该算法的时间复杂度是O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 判断单链表是否有环</div><div class="line"> * test：(null), (偶数个元素、偶数环元素的链表)， （偶数个元素且无环的链表），(奇数个元素、奇数环的链表)，</div><div class="line"> * （奇数个元素且无环的链表），（1个元素的无环链表），（1个元素有环链表），（只有2个元素且有环的链表），（圈链表）</div><div class="line"> * <span class="doctag">@param</span> head 待判断是否有环的链表</div><div class="line"> * <span class="doctag">@return</span> boolean 是否有环。false：无环。true：有环</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    Node p1 = head;</div><div class="line">    Node p2 = head;</div><div class="line">    <span class="keyword">while</span> (p2 != <span class="keyword">null</span> &amp;&amp; p2.next != <span class="keyword">null</span>) &#123;</div><div class="line">        p1 = p1.next;</div><div class="line">        p2 = p2.next.next;<span class="comment">//这一步需要考虑健壮性。即如果p2.next为null，则p2.next.next就会报异常。所以，要保证p2.next不为null</span></div><div class="line">        <span class="keyword">if</span> (p1 == p2) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="判断有环单链表中，环的长度"><a href="#判断有环单链表中，环的长度" class="headerlink" title="判断有环单链表中，环的长度"></a>判断有环单链表中，环的长度</h4><p><strong>思想</strong>：可以利用hasCycle的思路，如果找到相遇的结点了。那么p2从相遇的结点开始，再次走到此结点时走的距离，就是环的长度了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 判断有环单链表中，环的长度</div><div class="line"> * test：(null), (偶数个元素、偶数环元素的链表)， （偶数个元素且无环的链表），(奇数个元素、奇数环的链表)，</div><div class="line"> * （奇数个元素且无环的链表），（1个元素的无环链表），（1个元素有环链表），（只有2个元素且有环的链表），（圈链表）</div><div class="line"> * @param head 待计算环长度的链表</div><div class="line"> * @return int 若有环，返回环的长度；若无环，返回0；</div><div class="line"> */</div><div class="line">public static int cycleLength(Node head) &#123;</div><div class="line">    if (head == null || head.next == null) return 0;</div><div class="line">    Node p1 = head;</div><div class="line">    Node p2 = head;</div><div class="line">    Node kNode = null;//p1和p2相遇时的结点。</div><div class="line">    //p1和p2相遇</div><div class="line">    while (p2 != null &amp;&amp; p2.next != null) &#123;</div><div class="line">        p1 = p1.next;</div><div class="line">        p2 = p2.next.next;</div><div class="line">        if (p1 == p2) &#123;</div><div class="line">            kNode = p2;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //若p1和p2没有相遇，证明没有环</div><div class="line">    if (p2 == null || p2.next == null) return 0;</div><div class="line"></div><div class="line">    //再次移动p2一圈，计算环长度</div><div class="line">    int length = 1; //先包括p2结点</div><div class="line">    while (p2.next != kNode) &#123;</div><div class="line">        p2 = p2.next;</div><div class="line">        ++length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return length;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">---</div><div class="line">#### 获取单链表中，环的起始结点 </div><div class="line">若单链表中存在环，则返回环的起始结点。这个问题可以有三种思路：</div><div class="line">1. 利用环长度的方法计算。</div><div class="line">2. 从交点和相遇点推导步长规律。</div><div class="line">3. 配合HashSet一次遍历</div><div class="line"></div><div class="line">##### 利用环长度的方法计算</div><div class="line">利用环长度的方法计算比较简单</div><div class="line">- 定义两个指针pFront和pBack。</div><div class="line">- 假设环的长度为cycleLength，先让pFront走cycleLength步</div><div class="line">- 让pBack指向head</div><div class="line">- 两个指针同时移动，直到相遇，此时相遇的结点就是环的起始节点。*想不明白的动手画画就知道了。*</div><div class="line">```java</div><div class="line"> /**</div><div class="line"> * 获取单链表中，环的起始结点</div><div class="line"> * test：(null), (偶数个元素、偶数环元素的链表)， （偶数个元素且无环的链表），(奇数个元素、奇数环的链表)，</div><div class="line"> * （奇数个元素且无环的链表），（1个元素的无环链表），（1个元素有环链表），（只有2个元素且有环的链表），（圈链表）</div><div class="line"> * @param head 待处理的链表</div><div class="line"> * @return Node 环的起始结点。 若没有环，则返回null</div><div class="line"> */</div><div class="line">public static Node getCycleStartNode1(Node head) &#123;</div><div class="line">    int cycleLength = cycleLength(head);</div><div class="line">    if (cycleLength == 0) &#123;</div><div class="line">        return null; //环长度为0</div><div class="line">    &#125; else &#123;</div><div class="line">        Node pFront = head;</div><div class="line">        Node pBack = head;</div><div class="line">        for (int i = 0; i &lt; cycleLength; i++) &#123;</div><div class="line">            pFront = pFront.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        while (pFront != pBack) &#123;</div><div class="line">            pFront = pFront.next;</div><div class="line">            pBack = pBack.next;</div><div class="line">        &#125;</div><div class="line">        return pFront;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="从交点和相遇点推导步长规律"><a href="#从交点和相遇点推导步长规律" class="headerlink" title="从交点和相遇点推导步长规律"></a>从交点和相遇点推导步长规律</h5><p><strong>思想</strong>：对于有环链表，我们假设用环的起始结点startNode和相遇结点kNode(用hasCycle方法模拟走一下就知道了)，将链表分为3段。分别是k1，k2，k3.具体见下图：<br><img src="http://oc5u7idl7.bkt.clouddn.com/linkList/linknode.bmp" alt="linkList">  </p>
<p>假设判断其相遇时（hasCycle方法），一共走了k步。那么</p>
<ul>
<li>p1走的步数：<code>k1 + k2 = k</code>;</li>
<li>p2走的步数：<code>k1 + 2K2 + k3 = 2k</code>;<br>这样，两个公式联立就得<code>k1 = k3</code>.<br>换句话说，当两个结点相遇的时候，将p1再重新指向head，p1和p2一起往后移动，当再次相遇的时候，该结点就是环的起点。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取单链表中，环的起始结点</div><div class="line"> * test：(null), (偶数个元素、偶数环元素的链表)， （偶数个元素且无环的链表），(奇数个元素、奇数环的链表)，</div><div class="line"> * （奇数个元素且无环的链表），（1个元素的无环链表），（1个元素有环链表），（只有2个元素且有环的链表），（圈链表）</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> head 待处理的链表</div><div class="line"> * <span class="doctag">@return</span> Node 环的起始结点。 若没有环，则返回null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getCycleStartNode2</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Node p1 = head;</div><div class="line">    Node p2 = head;</div><div class="line">    <span class="comment">//找到相遇的结点。</span></div><div class="line">    <span class="keyword">while</span> (p2 != <span class="keyword">null</span> &amp;&amp; p2.next != <span class="keyword">null</span>) &#123;</div><div class="line">        p1 = p1.next;</div><div class="line">        p2 = p2.next.next;</div><div class="line">        <span class="keyword">if</span> (p1 == p2) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (p2 == <span class="keyword">null</span> || p2.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//没有环</span></div><div class="line">    <span class="comment">//将p1重新指向head，p1和p2一起走，直到两个指针再次相遇</span></div><div class="line">    p1 = head;</div><div class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</div><div class="line">        p1 = p1.next;</div><div class="line">        p2 = p2.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="配合HashSet一次遍历"><a href="#配合HashSet一次遍历" class="headerlink" title="配合HashSet一次遍历"></a>配合HashSet一次遍历</h5><p><strong>思想</strong>：可以在遍历的时候，将链表结点放入HashSet中，当遍历时发现有此元素，则该结点就是环的起始结点。这种方法很简洁，但是当结点比较多的时候，空间开销太大。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取单链表中，环的起始结点</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> head 待处理的链表</div><div class="line"> * <span class="doctag">@return</span> Node 环的起始结点。 若没有环，则返回null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getCycleStartNode3</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    HashSet nodeSet = <span class="keyword">new</span> HashSet();</div><div class="line">    Node p = head;</div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; !nodeSet.contains(p)) &#123;</div><div class="line">        nodeSet.add(p);</div><div class="line">        p = p.next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果无环，此时p == null，如果有环，此时p指向环的起始结点。</span></div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="删除单链表中指定结点"><a href="#删除单链表中指定结点" class="headerlink" title="删除单链表中指定结点"></a>删除单链表中指定结点</h4><p>这个问题有个特殊要求，就是要求时间复杂度<code>O(1)</code><br>常规的思路：对于这样一段链表：<code>n0 -&gt; n1 -&gt; n2 -&gt; n3 -&gt; n4</code> 如果要删除结点<code>n2</code>，可以让<code>n1</code>指向<code>n3</code>。然后释放<code>n2</code>。这样的话需要找到结点<code>n1</code>，时间复杂度为<code>O(n)</code>   </p>
<p><strong>思想</strong>：对于单链表，可以将<code>n3</code>复制到<code>n2</code>，然后删除<code>n3</code>即可。<em>这样的方法在java中，如果是删除链表最后一个元素，仍然需要找前面的元素。</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除单链表中指定结点</div><div class="line"> * test:(null,null),(d1, null),(null, d2),(链表中间的结点) ，(链表结尾的结点)，（链表的头结点）</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> head         待删除的链表</div><div class="line"> * <span class="doctag">@param</span> nodeToDelete 待删除结点</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node head, Node nodeToDelete)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || nodeToDelete == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span> &amp;&amp; nodeToDelete == head) &#123;<span class="comment">//当链表只有1 个元素，并且删除此元素</span></div><div class="line">        head = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果nodeToDelete是最后一个结点，或链表只有1个结点。则直接置为null，倒数第2个结点的next就指向了null</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (nodeToDelete.next != <span class="keyword">null</span>) &#123;  <span class="comment">//删除中间结点</span></div><div class="line">        nodeToDelete.data = nodeToDelete.next.data;</div><div class="line">        nodeToDelete.next = nodeToDelete.next.next;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//删除链表最后一个结点</span></div><div class="line">        Node preNode = head;</div><div class="line">        <span class="keyword">while</span> (preNode.next != nodeToDelete) &#123;</div><div class="line">            preNode = preNode.next;</div><div class="line">        &#125;</div><div class="line">        preNode.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，先总结到这里吧。  </p>
<hr>
<p>参考资料：</p>
<blockquote>
<p><a href="http://blog.csdn.net/fightforyourdream/article/details/16353519" target="_blank" rel="external">http://blog.csdn.net/fightforyourdream/article/details/16353519</a><br><a href="http://www.jb51.net/article/71885.htm" target="_blank" rel="external">http://www.jb51.net/article/71885.htm</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用R语言绘制词云]]></title>
      <url>https://FergusChen.github.io/2016/08/24/%E4%BD%BF%E7%94%A8R%E8%AF%AD%E8%A8%80%E7%BB%98%E5%88%B6%E8%AF%8D%E4%BA%91/</url>
      <content type="html"><![CDATA[<p>R语言不仅有丰富的包可以用于数据统计分析，而且可以对数据进行可视化。这边文章主要介绍下如何用R语言绘制词云。<br><a id="more"></a>  </p>
<blockquote>
<p>工具：  </p>
<ul>
<li>R语言IDE  </li>
<li>ggplot2包  </li>
<li>wordcloud包  </li>
</ul>
</blockquote>
<h4 id="安装作图包"><a href="#安装作图包" class="headerlink" title="安装作图包"></a>安装作图包</h4><p>因为绘制词云需要用到ggplot2包和wordcloud包。所以，可以在R studio输入如下命令，需要选择mirror：  </p>
<pre><code>chooseCRANmirror()
</code></pre><p>之后，就可以在这个镜像中安装需要的作图包：  </p>
<pre><code>install.packages(&quot;ggplot2&quot;)
install.packages(&quot;wordcloud&quot;)
</code></pre><h4 id="预备数据"><a href="#预备数据" class="headerlink" title="预备数据"></a>预备数据</h4><p>绘制词云需要的数据格式就是“词语\t权重”，我们可以将每个topic的词语放在一个文本文档中，有多少个topic就绘制多少张词云图。<br>如下是一个topic的词语：  </p>
<p><img src="http://oc5u7idl7.bkt.clouddn.com/words.png" alt="旅游景点">  </p>
<h4 id="绘制词云"><a href="#绘制词云" class="headerlink" title="绘制词云"></a>绘制词云</h4><p>如下代码便用于生成词云。其中，path为所有topic的文本文档所在路径。topicNum为topic的个数。接下来就是调用作图包进行绘制，其中字体，大小都可以设定，但是其它很多字体绘制出来的词云会出现词语重叠的现象，很奇怪，目前我也不知道什么原因。希望哪位前辈能指教一下，不胜感激。  </p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">path &lt;- <span class="string">"D:/workspace/wordcloud/cloud0/"</span></div><div class="line">topicNum &lt;- <span class="number">2</span> </div><div class="line"></div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> seq(<span class="number">0</span>,topicNum-<span class="number">1</span>,<span class="number">1</span>))&#123;</div><div class="line">    infile &lt;- paste(path, i, <span class="string">".txt"</span>, sep=<span class="string">""</span>)</div><div class="line">    outfig1 &lt;- paste(path, <span class="string">"distribution_"</span>, i, <span class="string">".png"</span>, sep=<span class="string">""</span>)</div><div class="line">    outfig2 &lt;- paste(path, <span class="string">"topic_"</span>, i, <span class="string">".png"</span>, sep=<span class="string">""</span>)</div><div class="line"></div><div class="line">    data &lt;- read.table(infile, fileEncoding = <span class="string">"UTF-8"</span>, header=<span class="literal">TRUE</span>, sep=<span class="string">"\t"</span>)</div><div class="line">    data0 = data.frame(word=data$tag, freq=data$point)</div><div class="line">    data1=cbind(data0, order=order(data0$freq,decreasing=<span class="literal">TRUE</span>))</div><div class="line"></div><div class="line">    <span class="comment">##分布图</span></div><div class="line">    png(file=outfig1, bg=<span class="string">"transparent"</span>)</div><div class="line">        <span class="keyword">library</span>(ggplot2)</div><div class="line">        qplot(freq, data=data1, geom=<span class="string">"histogram"</span>, binwidth=<span class="number">1</span>) </div><div class="line">        <span class="comment">#d=ggplot(data1, aes(x=freq))+xlim(0,0.00005)</span></div><div class="line">        <span class="comment">#d+geom_freqpoly()</span></div><div class="line">    dev.off()</div><div class="line"></div><div class="line">    <span class="comment">##词云</span></div><div class="line">    png(file=outfig2, bg=<span class="string">"transparent"</span>)    </div><div class="line">        <span class="comment">#设置一个颜色系：</span></div><div class="line">        <span class="keyword">library</span>(RColorBrewer)</div><div class="line">        col=brewer.pal(<span class="number">8</span>, <span class="string">"Dark2"</span>)</div><div class="line">        <span class="comment">#设置字体</span></div><div class="line">        windowsFonts(myFont=windowsFont(<span class="string">"微软雅黑"</span>))</div><div class="line">        <span class="comment">#画图</span></div><div class="line">        <span class="keyword">library</span>(wordcloud)</div><div class="line">        wordcloud(data1$word, data1$freq, random.order=<span class="literal">FALSE</span>, random.color=<span class="literal">FALSE</span>, colors=col, family=<span class="string">"myFont"</span>, min.freq=<span class="number">0.1</span>)</div><div class="line">        <span class="comment">###可以先排序限制TOPN入画，也可以直接在函数上加min.freq=0.00001，限制TopN入画</span></div><div class="line">    dev.off()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，绘制得到的结果示例：<br><img src="http://oc5u7idl7.bkt.clouddn.com/cloud2.png" alt="旅游">　<img src="http://oc5u7idl7.bkt.clouddn.com/cloud1.png" alt="专业"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Scala中的Option、None、Nothing、Null和Nil]]></title>
      <url>https://FergusChen.github.io/2016/08/22/Scala%E4%B8%AD%E7%9A%84Option%E3%80%81None%E3%80%81Nothing%E3%80%81Null%E5%92%8CNil/</url>
      <content type="html"><![CDATA[<p>在Scala中有几个容易混淆的类型，像是None、Nothing、Null、Nil等。在实际编程中又经常会遇到。要有一个清楚区分，这边文章就简单做个总结。<br><a id="more"></a>  </p>
<p>首先可以参考一下scala的继承层次树：<br><img src="http://oc5u7idl7.bkt.clouddn.com/scala%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1.png" alt="scala中的Null" title="scala继承层次树"></p>
<p>可以看到，在Scala中，所有类型的父类是Any，其声明了isInstanceOf、asInstanceOf、equal、hashCode、toString等方法。<br><strong>Any</strong>有两个直接子类：AnyVal和AnyRef。<br><strong>AnyVal</strong>是所有值类型的父类，没有追加任何方法，只是所有值类型的一个标记。<br><strong>AnyRef</strong>是所有引用类型的父类，追加了来自Object类的wait、notify等监听方法。<br>所有Scala类都实现了ScalaObject这个标记接口，该接口只是一个标记，没有定义任何方法。  </p>
<p>在这个继承层次树中的底端，有两个特殊的类型：Null和Nothing<br><strong>Null</strong>只有一个实例，就是null值。我们可以将null赋值给任何引用类型，但不能赋值给值类型。<br><strong>Nothing</strong>是任意类型的子类。Nothing类没有实例，但可以表示任意类型。所以经常用于泛型结构，如空列表Nil的类型就是List[Nothing]，它是List[T]的子类型，T可以是任何类。</p>
<p>接下来对其它的几个类型做说明：</p>
<p><strong>Unit</strong>类型相当于java中的void，其只有一个值，就是()。Unit只是AnyVal的子类，但编译器允许任何值被替换成()</p>
<p><strong>None</strong>类型是Option类的子类，代表不存在的值（non-existent）  </p>
<p><strong>Some[A]</strong> 类型也是Option类的子类，代表类型A存在的值。</p>
<p><strong>Option</strong>代表一个可选的值。既可以是Some[A]的一个实例，也可以是None，即不存在。scala推荐在可能返回空对象的函数中，声明返回值为Option[A]。Option类型中也提供isEmpty，get，getOrElse等方法来操作和判断。</p>
<p><strong>Nil</strong>是一个空的List，其相当于List[Nothing]。  </p>
<blockquote>
<p>如果本文有出于我个人理解或表达的错误，还望指正。<br>如果本文有涉及到版权、知识产权的问题，请及时与我联系。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在线广告的发展过程]]></title>
      <url>https://FergusChen.github.io/2016/08/19/%E5%9C%A8%E7%BA%BF%E5%B9%BF%E5%91%8A%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>　计算广告已经成为当下十分热门的话题。但是，要 真正了解计算广告，仅仅从一些计算公式、业务规则等入手，还是很受局限的。因为广告行业对我们来说都不陌生，而在线广告也从传统的合约广告到定向广告，再到现在的竞价广告，经历了多次变革，每一步都在广告效果、广告收益等方面有很大的革新。因此，要了解计算广告，最好的办法就是了解整个在线广告的发展历程。下面就从广告的定义入手，简要介绍在线广告的发展过程。<br><a id="more"></a></p>
<blockquote>
<p>全文引自刘鹏、王超著的《计算广告·互联网商业变现的市场与技术》  </p>
</blockquote>
<h4 id="什么是广告？"><a href="#什么是广告？" class="headerlink" title="什么是广告？"></a>什么是广告？</h4><p>引用Willianm F. Arens在《当代广告学》中给出的定义：<br><em>广告是由已确定的出资人通过各种媒介进行的有关产品（商品：服务和观点）的，通常是有偿的、有组织的、综合的、劝服性的非人员的信息传播活动。</em><br>这一定义中有两个关键点，首先，它指出了广告活动的两个主动参与方：<strong>出资人</strong> (sponsor) 和<strong>媒体</strong> (medium)。这其实是广告行业的两个最基本的角色<code>（还有一个被动的角色就是受众）</code>。其实说白了，这两个角色就是：需求方（demand）和供给方（Supply）。<br>这里的需求方可以是广告主(advertiser)、代表广告主利益的代理商（agency）或其他技术形态的采买方；这里的供给方可以是媒体，也可以是其他技术形态的变现平台。另外，要特别注意的是，广告还有一个被动的参与方，即受众（audience）。  </p>
<p>请大家从现在开始就牢牢建立起这样的概念：<code>出资人、媒体和受众这三者的利益博弈关系是广告活动永远的主线</code>，这一主线将贯穿于商业和产品形态的整个演化过程。另外，该定义还阐明了广告必须是有偿的、非人员的信息传播活动。这两点限制，前者使得广告的目标变得明确，后者使得过这一目标可以采用计算的方式来优化，而这些都是计算广告产生的基础。  </p>
<h4 id="广告的目的是什么？"><a href="#广告的目的是什么？" class="headerlink" title="广告的目的是什么？"></a>广告的目的是什么？</h4><p>广告这一商业行为，其本质目的是什么呢？在不同的时代，广告主与媒体对这一问题存在着不同的认知。在传统媒体时代供给方与需求方在市场地位上有相当的距离，不论你运营的是电视台、机场或杂志都与大多数广告主需要的转化行为之间有相当大的差距。因此这一阶段广告的目的是希望借助媒体的力量来快速接触大量用户以达到宣传品牌形象、提升中长期购买率与利润空间的目的。这种目的的广告称为<code>品牌广告</code>（brand awareness)。当然，也有许多广告商希望能利用广告手段马上带来大量的购买或其他转化行为。这种目的的广告称为<code>直接效果广告</code>（direct Response）。 有时也简称为<code>效果广告</code>。  </p>
<p>仍然引用Willianm F. Arens在《当代广告学》中给出的见解：<br><em>广告的根本目的是广告主通过媒体达到低成本的用户接触。</em>  </p>
<p>也就是说，按某种市场意图接触相应的人群，进而影响其中的潜在用户，使他们选择广告主产品的几率增加，或者对产品性价比的苛求程度降低，这才是广告的根本目的。至于短期内的转化效果，由于市场意图或媒体性质的不同，并不是直接可比。换句话说，如果仅仅以转化效果为目的来思考问题可能会背离投放广告的正确方法论。举个例子，某感冒药广告商如果以短期效果为导向那么最佳的策略是把广告投放给那些现在感冒的人。不过这显然是一个荒谬的决策；再比如某汽车广告商为了提升自己的品牌形象，希望对自己竞品品牌的用户加强宣传，而对于这部分人群，广告的直接效果甚至有可能比随机投放还要差。  </p>
<h4 id="在线广告简史"><a href="#在线广告简史" class="headerlink" title="在线广告简史"></a>在线广告简史</h4><p>在讨论广告技术之前，我们先浏览一下在线广告发展的历程。因为广告市场的概念、技术和术语繁多，如果不是对这些有基本的了解，很难深入探讨具体的产品。回到20世纪末，那时的在线媒体（如AOL、Yahoo!等网站）刚刚产生不久。他们已经取得了不错的流量规模。可是投资人当然希望这些媒体也能够给他们带来真金白银。要对这些线上流量进行变现，最直接的方法就是把网站的HTML页面当成杂志的版面，在里面插入广告位。供给方有了，那么需求方呢？线下的广告代理公司也就把这些网站当成一本本新的杂志，按原来的思路和逻辑进行采买。这种在互联网上展示广告创意的产品形式称为 <code>展示广告
(display advertising)</code>，也叫显示广告。这一阶段的展示广告售卖模式称为<code>合约广告(agreement-based advertising)</code>。即采用<strong>合同约定</strong>的方式确定某一广告位在某一时间段为某特定广告主所独占，并且根据双方的要求，确定广告创意和投放策略。当然，这样的采买模式还没有对计算的需求，因为此时唯一需要的就是把广告主的创意作为一个HTML的片段插入到媒体的页面中。然而，情况变化很快，互联网媒体为了营收的增长，希望逐年甚至逐季提高自己的广告位报价。在流量快速增长或者数字广告逐渐为广告主认知的阶段，提价是比较容易被市场接受的。可是当媒体的流量和品牌认知度都相对稳定以后，又有什么新的提高收入的办法呢？  </p>
<p>互联网广告运营者们经过探索，很快就发现了在线广告不同于传统媒体广告的本质特点： <strong>我们可以对不同的受众呈现不同的广告创意</strong>！在今天看来再平常不过的这个观念，实际上是在线广告的效果和市场规模不断发展的核心驱动力。认识到这一点，媒体找到了一条能使广告位报价继续提高的思路。例如，可以把某广告位的男性受众和女性受众卖给不同的广告主，比如对男性受众展示某剃须刀品牌的广告，而对女性受众展示某化妆品品牌的广告，这样的广告投放方式称为<code>定向广告（targeted advertising）</code>。很显然，这样的广告系统已经对计算技术产生了两个具体需求：一是<code>受众定向（audience targeting)</code>，即通过技术手段标定某个用户的性别、年龄或其他标签；二是<code>广告投放（ad serving）</code>，即将广告投送由直接嵌入页面变为实时响应前端请求并根据用户标签自动决策和返回合适的广告创意。由于从传统的品牌广告延伸而来，此时的定向广告仍然以合约的方式进行。媒体向广告主保证某个投放量，并在此基础上确定合同的总金额以及投放量未完成情况下的赔偿方案。这种<code>担保式投送(Guaranteed Delivery, GD )</code>的交易方式逐渐成为互联网合约式广告的主要商业模式。一般来说，这样的合约仍然主要面向品牌广告主，并且遵循按<code>千次展示付费（Cost per Mille, CPM）</code>的计费方式。  </p>
<p>合约广告系统中有一个重要的计算问题，即在满足各合约目标受众量要求的同时尽可能为所有广告商分配到质更好的流量。这一问题有两个难点：一是如何有效地将流量分配到各个合约互相交叉的人群覆盖上；二是要在在线的环境下实时地完成每一次展示决策，这个问题称为<code>在线分配(online allocation)</code>。 如果将各合约的量看作约束条件，将某种度量下的质看作目标函数，可以利用<code>带约束优化(constrained optimization)</code>的数学框架来探索这一问题。为了得到在线环境下切实可行的解决方案，学术界和工业界的同仁在理论和工程方面进行了大量的研究，有一些高效且简便的实用方案已经为各媒体广泛采用。  </p>
<p>需要注意，展示广告领域定向投放的最初动机是供给方为了拆分流量以获得更高的营收，如果一开始就提供非常精细的定向，反而会造成售卖率的下降。因此，最初的定向标签往往都设置在较粗的粒度上，最典型的是一些人口属性标签。受众定向显然更符合需求方的口味和利益——不要忘了，广告市场的钱全部是来自需求方的，他们的利益被满足得越好，市场的规模就会越大。因此，受众定向产生以后，市场向着精细化运作的方向快速发展。这一发展主要有两方面的趋势：一是定向标签变得越来越精准；二是广告主的数量不断<br>膨胀。在这些趋势下，仍然按照合约的方式售卖广告会遇到越来越多的麻烦。首先，很难对这些细粒度标签组合的流量做准确预估；其次，当一次展示同时满足多个合约的时候，仅仅按照量约束下的在线分配策略进行决策有可能浪费掉了很多本来可以卖得更贵的流量。既然量的约束带来了这些麻烦，有没有可能抛弃量的保证而采用最唯利是图的策略来进行广告决策？这样的思路催生了计算广告历史上革命性的产品模式——<code>竞价广告（auction-based advertising)</code>。在这种模式下，供给方只向广告主保证质，即单位流量的成本。但不再以合约的方式给出量的保证。换言之，对每一次展示都基本按照收益最高的原则来决策。  </p>
<p>上面是从展示广告的发展看竞价产生的原因，实际历史的足迹却并非如此。竞价广告产生的最初场景是在互联网广告最主要的金矿——搜索广告（search ad）中。在以Google为代表的搜索引擎在技术成熟以后，迅速成为互联网新的入口。与门户网站不同，搜索引擎从一开始就没有被当作媒体来看待，因此搜索流量的变现也采用了与服务自然结合的<code>付费搜索(paid search 或 sponsored search)</code>模式。从广告的视角来看，也可以把付费搜索看作种定向广告，即根据用户的即时兴趣定向投送的广告，而即时兴趣的标签就是关键词。很显然，这种定向广告从一开始就直接达到了非常精准的程度也就很自然地采用了竞价的方式售卖。  </p>
<p>搜索广告产生了巨大的收益以后，搜索引擎开始考虑将这样的变现方式推广到其他互联网媒体上：将用户的即时兴趣标签由搜索词换成正在浏览页面中的关键词，可以将这套竞价广告系统从搜索结果页照搬到媒体页面上，这就产生了<code>上下文广告(contextual advertising)</code>。上下文广告的初期，创意的形式也是与搜索广告一样的文字链接，许多产品讨论将它与展示广告分开对待，不过当我们把它与上一段中精细化定向的展示广告对比来看时就知道，这样的区分实际上没有必要，或许从创意形式上把展示广告和文字链广告区别开更符合分类的逻辑。  </p>
<p>从宏观市场上看，竞价广告与合约广告有很大的不同。没有了合约的保证，大量的广告主处在一个多方博弈的环境中。与直觉不同的是，在如何收取广告主费用这一点上，我们并非按照微观上最优的方案实施就可以达到整个市场最大的收益。关于定价机制的深入研究，产生了<code>广义第二高价(Generalized Second Price, GSP)</code>这一竞价重要的理论。  </p>
<p>基于竞价机制和精准人群定向这两个核心功能，在线广告分化出了<code>广告网络（ad Network, ADN）</code>这种新的市场形态。它批量地运营媒体的广告位资源，按照人群或上下文标签售卖给需求方，并用竞价的方式决定流量分配。广告网络的结算以按<code>点击付费(Cost per Click，CPC)</code>的方式为主，这一点有数据和业务方面多层次的原因，在本书的后面会详细探讨。虽然我们不太能指这种方式的<code>千次展示收益(Revenue per Mille, RPM)</code>可以达到合约式品牌广告的水平，但它使得大量中小互联网媒体有了切实可行的变现手段：这些媒体有一定的流量，但还不值得建立自己的销售团队面向品牌广告商售卖，直接把自己的广告<code>库存(inventory)</code>托管给ADN，借助ADN的销售和代理团队为自己的流量变现。  </p>
<p>ADN既然只通过出价接口提供价格约定，那么由谁来保证量呢？自然会有需求方的某种产品来完成。当ADN产生以后，代理公司当然也要对广告采买方式做出调整，因为此时的流量采买发生了几点显著变化：一是更多地面向受众而非媒体或广告位进行采买，这当然是与受众定向的流行有直接关系；二是需求方的代理需要采用技术的手段保证广告主量的要求，并在此基础上帮助广告主优化效果，这又是一个与在线分配类似的带约束优化问题。但是，实际上这个问题有着本质的不同：由于只能在ADN定义好的定向标签组合上预先指定出价，而不能控制每一次展示的出价，因此，市场看起来像一个黑盒子，需求方只能靠选择合适的标签组合以及阶段性调整出价来间接控制效果。这种面向多个ADN或媒体按人群站式采买广告并优化投入产出比的需求方产品，我们称为<code>交易终端（Trading Desk, TD）</code>  </p>
<p>在ADN中，核心的竞价逻辑是封闭的，这不能满足需求方越来越明确的利益要求。试想下面两个例子（1）某电子商务网站需要通过一次广告投放来向它的忠实用户推广某产品；（2）某银行希望通过自己的信用卡用户在网络上找到类似的潜在用户群，并通过广告争取这批潜在用户。很显然，AND很难直接为这两个需求提供人群标签。定制化需求催生了一种开放的竞价逻辑，让需求方按自己的人群定义来挑选流量，这就是<code>实时竞价(Real Time Bidding，RTB)</code>，它是将拍卖的过程由广告主预先出价，变成每次展示时实时出价。只要把广告展示的上下文页面URL以及访客的用户标识等信息传给需求方，它就有充分的信息来完成定制化的人群选择和出价。于是，市场上产生了大量聚合各媒体的剩余流量并采用实时竞价方式为他们变现的产品形态——<code>广告交易平台(ad Exchange，ADX)</code>。这个名称让我们很容易联想起股票交易所。事实上，如果我们把ADN的交易方式想象成场外交易市场(over-the-counter market)， 那么ADX与股票交易所确实有着类似的作用。  </p>
<p>通过实时竞价的方式，按照定制化的人群标签购买广告，这样的产品就是<code>需求方平台(Demand Side Platform, DSP)</code>。由于实时竞价主要采用按展示次数计费的方式（本书后面部分会具体讨论其原因），DSP需要尽可能准确地估计每一次展示带来的期望价值。在这点上，DSP比TD要方便多了，因为充分的环境信息使得深入的计算和估计成为可能，基于DSP的广告采买非常类似于股票市场上的程序交易，我们把这样的广告采买方式也叫作<code>程序化交易(programmatic trade)</code>。除了RTB以外，还有其他几种程序购买的交易方式，如<code>优选(prefered deals)</code>以及<code>私有交易市场（Private Market Place， PMP ）</code>等。可以预见，在线广告中程序化交易的作用和地位将会不断加强，这是由数字广告的本质特点以及广告主利益最大化的趋势所决定的。  </p>
<p>由于在线广告存在着较为复杂的市场结构，LUMA Partners对北美市场的主要代表公司进行非常全面的总结，并绘制成了下图中的“display LUMAscape”。  </p>
<p><img src="/images/display-lumascape-2014.jpg" alt="display-lumascape"></p>
<p>这一图谱的骨架与上面我们介绍的在线广告简史有着非常紧密的联系，因此也是本书在广告产品方面重要的提纲。基本上可以说，这一图谱是从两端向中间逐渐发展和形成的：首先是合约阶段，广告主通过代理公司从媒体方采买广告，而媒体方的广告投放机则负责完成和优化各个广告主的合约；然后，市场进化出了竞价售卖方式从而在靠近供给方产生了ADN这样的产品形态，而需求方的代理公司为了适应这一市场变化，孵化出了对应的<code>媒介采买平台(media buying platform)</code>； 最后，当市场产生了实时竞价方式交易时，供给方进化出了ADX，而需求方则需要用DSP与其对接来出价和投送广告。图中的下半部分多是一些对这一骨干市场结构起支持作用的产品或者在细分领域的特异化产品。我们在后面介绍到相关部分时将会给出相应的介绍。  </p>
<p>总结一下，在在线广告发展的历史上，定向技术和交易形式的进化是一条主线。从最初的固定位置合约交易发展到进行受众定向、按展示量结算的合约交易再到竞价交易方式，并最终发展成开放的实时竞价交易市场。这条主线的核心驱动力是让越来越多的数据源为广告决策提供支持，从而提升广告的效果。除了这条交易形态的主线，互联网广告产品还有另外一条发展线路，即产品展现逻辑上的发展：在展示广告的最初阶段，广告位作为与内容相对独立的单元来决策和运营，并且完全以优化收入为目标；但同时人们从搜索广告和社交网络信息流广告中得到了启发——将内容与广告对立起来未必是一个好的选择。搜索广告和社交网络信息流广告这两种广告产品正是由于与内容的展现和触发逻辑有着高度的一致性，才使得它们的效果突出。沿着这样的思路，将内容与广告以某种方式统一决策或排序的广告产品——<code>原生广告（Native AD）</code>在近年来得到了工业界越来越多的关注。如何将原生的决策方式与前面介绍的广告市场已经非常成熟的规模化交易逻辑相结合是目前互联网广告产品发展的热点。需要特别说明的是，原生广告的思路在移动设备这样屏幕尺寸受限的环境下将会成为一个非常有前景的发展方向，这方面的进展我们将在第7章中具体讨论。  </p>
<blockquote>
<p>以上内容基本上完全摘自刘鹏、王超著的《计算广告·互联网商业变现的市场与技术》。这本书介绍得非常清晰，对上文中提到很多概念也做了详细的解释。若要深入了解计算广告，可以在这本书中查阅。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[.gitignore不起作用的解决方案]]></title>
      <url>https://FergusChen.github.io/2016/08/18/gitignore%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>.gitignore文件的作用是让git在版本控制时忽略一些文件，知道哪些文件不需要添加到版本库中，像是jar包、.iml项目文件等等。但有时候发现明明在.gitignore忽略的文件，还会出现在版本库中，.gitignore好像无效了，不起作用！！！ 这里就简单说明一下问题的原因。<br><a id="more"></a>  </p>
<p>首先说下<strong>.gitignore文件</strong>。虽然使用git可以对任何文件进行版本控制，包括源代码、二进制文件、配置文件、甚至视频等多媒体文件。但是，通常在项目中不需要对某些文件进行版本控制。比如jar文件，有的jar文件甚至有100多兆，而且每次编译都会重新生成，也根本没必要进行版本控制。所以，定义.gitignore文件还是很有必要的。  </p>
<p>.gitignore文件跟.git在同级目录下，通常在项目的根目录下。在git init初始化时，会生成.git文件夹（隐藏的），<strong>但默认是不会生成.gitignore文件的</strong>。所以，需要手动添加.gitignore文件，然后可以参考这个项目，确定哪些文件可以被忽略：<a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a>  </p>
<p>出现.gitignore文件无效的原因就是，在git初始化时，忘记添加.gitignore文件了。已经add commit push过了之后，才添加.gitignore文件。<code>.gitignore文件只对还没有加入版本管理的文件起作用，已经添加到版本管理中的文件，.gitignore也不会负责删除。</code>  </p>
<p>这样的话，只能手动删除缓存中的文件，然后再add、commit、push。运行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git rm -r --cached .</div><div class="line">git add .</div><div class="line">git commit -m &quot;gitignore重新配置&quot;</div></pre></td></tr></table></figure></p>
<p>之后，.gitignore就起作用了。注意每次修改.gitignore都需要清除缓存啊。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编程中的时区和时间]]></title>
      <url>https://FergusChen.github.io/2016/08/17/%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%97%B6%E5%8C%BA%E5%92%8C%E6%97%B6%E9%97%B4/</url>
      <content type="html"><![CDATA[<p>在开发过程中常常会碰到时区的问题。有时候明明要获取当前时间，但结果却倒流了8个小时。在打印时间时，也会出现UTC、GMT等后缀。这些关键字都代表什么意思？在开发中应该怎么处理呢？这里就做一个简要的总结。<br><a id="more"></a>  </p>
<p>我想从时区的简要介绍开始，讨论一下我所遇到过的时区处理问题。<br>由于地球的自转周期是24小时，人们就将地球按经度划分为24个时区。这样，以英国伦敦格林威治天文台的经线（本初子午线）为零时区中心线，向东向西各12个时区。每个时区15度（360/24），这样相邻两个时区的时区中心线就正好相差1个小时。北京位于东八区，地球自西向东自转，北京就比伦敦早8个小时。换句话说，北京的中午12点，伦敦还是凌晨4点。注：有时候北京比伦敦早7个小时，是因为伦敦施行日光节约时制（DST）具体可以google。<br><img src="http://oc5u7idl7.bkt.clouddn.com/timezone.gif" alt="时区图">  </p>
<p><strong>GMT</strong>：Greenwich Mean Time，即格林威治标准时间，又叫世界时。GMT是以地球自转为基础的时间计量系统。该系统源自于十七世纪成立的英国格林威治皇家天文台，其观测所门口墙上有一个标志24小时的时钟，天文学观测将每日太阳穿过本初子午线的瞬间定为正午时刻。此后，全世界都以GMT时间作为标准时间参考点，根据时区差可以方便地计算当地时间（有时候看到GMT + 8就是这样换算）。但是，因为地球在椭圆轨道运行，其自转是不规则的，所以，GMT时间可能与实际的太阳时会有偏差。所以，从1924年，格林威治天文台每隔1个小时就向全世界发放调时信息。直到后来，有UTC的存在，GMT时间就不再作为世界标准时间。  </p>
<p><strong>UTC</strong>：Coordinated Universal Time，即协调世界时间，又叫世界标准时间。是以原子时秒长为基础的时间度量系统。UTC在时间上尽量接近于世界时（GMT），其计算过程非常严谨精密。并且UTC时间的精确度高，每日保持与世界时不超过0.9秒的误差。若因为地球自转不均匀而导致原子时和世界时误差变大时，UTC就通过加上正或负的闰秒来补偿，这个由位于巴黎的国际地球自转事务中央局负责。目前，UTC已经作为万维网的标准，广泛应用于计算机系统中了。  </p>
<p>还有很多时间标准，像是DST、原子时、太阳时、恒星时等，这里就不多讨论了。就是GMT、UTC，若要展开介绍其计算方法、发展历程、应用范围等，内容还是非常多的。但作为程序员，不搞天文地理，没必要太深入。还是简单了解一下，然后就开始应用吧。<br>ps：综上所述，若不追求太精确，GMT和UTC时间是一样的。但实际应用中都有时区的问题。  </p>
<hr>
<p>下面分别从iOS、pig、oozie中总结一下date类型关于时区的处理。  </p>
<h4 id="iOS中的时区问题"><a href="#iOS中的时区问题" class="headerlink" title="iOS中的时区问题"></a>iOS中的时区问题</h4><p>在iOS中，从iOS4.1开始，<code>[NSDate date]</code>方法获取的当前时间是0时区的时间，即比北京时间晚8个小时(倒流8个小时，原本北京时间是20:00，但0时区是12:00)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSDate *date1 = [NSDate date];</div><div class="line">NSString *date2Str = @&quot;2016-08-17 20:15&quot;;</div><div class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init];</div><div class="line">[dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm&quot;];</div><div class="line">NSDate *date2 = [dateFormatter dateFromString:date2Str];</div><div class="line"></div><div class="line">NSLog(@&quot;date1:%@&quot;, [dateFormatter stringFromDate:date1]);</div><div class="line">NSLog(@&quot;date2:%@&quot;, [dateFormatter stringFromDate:date2]);</div></pre></td></tr></table></figure></p>
<p>比如当前时间是20:15，则在第date1代码处打断点，查看到时间如下:<br><img src="http://oc5u7idl7.bkt.clouddn.com/date1.png" alt="date1">  </p>
<p>然而，用NSDateFormatter对象转换成字符串，打印出来的时间却是当前时间:<br><img src="http://oc5u7idl7.bkt.clouddn.com/date1Formatter.png" alt="date1Log">    </p>
<p>所以，在iOS中，NSDateFormatter对象在对时间格式化的时候，已经处理了时区问题。具体来说，NSDateFormatter是将NSDate的0时区处理成当前时区，然后才转化成时间字符串。反过来，如果有一个时间字符串，要通过NSDateFormatter转换成NSDate类型，那么NSDateFormatter也会把时间处理成0时区的时间，如下图:<br><img src="http://oc5u7idl7.bkt.clouddn.com/date2.png" alt="date2">  </p>
<p>可见，在iOS中，时区问题被NSDateFormatter对象隐藏了.若不涉及到日历、本地通知等操作，程序员也不需要考虑时区。但是，并不是所有的NSDate都是用NSDateFormatter来处理的。可能遇到意想不到的两个时区的时间比较。这样如果要把其中一个时间修改为当前时区的时间，则可以用如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSDate *)currentLocalDate&#123;</div><div class="line">    NSDate *date = [NSDate date];</div><div class="line">    NSTimeZone *zone = [NSTimeZone systemTimeZone];</div><div class="line">    NSInteger interval = [zone secondsFromGMTForDate:date];</div><div class="line">    NSDate *localDate = [date dateByAddingTimeInterval:interval];</div><div class="line">    return localDate;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="pig中的时区问题"><a href="#pig中的时区问题" class="headerlink" title="pig中的时区问题"></a>pig中的时区问题</h4><p>在pig抽取数据的时候，记得一次使用<code>value.fields.data#&#39;timestamp&#39; as timestamp:long</code>,获取日志中的时间，然后用<code>UnixToISO(timestamp) as ISOTime</code>进行时间戳的转换，发现得到的结果有很多发生在凌晨2点到5点。后来发现是时区的问题，本身日志应该是在上午10点、11点的。这个目前还不太清楚是什么原因，可能也是环境搭建的问题，回头有精力再深究吧。如果哪位高手知道原因，希望能交流一下，不胜感激。  </p>
<h4 id="oozie的时区问题"><a href="#oozie的时区问题" class="headerlink" title="oozie的时区问题"></a>oozie的时区问题</h4><p>在oozie启动定时任务的时候，时区问题就更加重要了。但是oozie的时区问题比较棘手，也不知道是因为环境搭建的问题，还是其它原因，我在部署oozie任务时，还要考虑8个小时的时差。（感觉环境搭建好麻烦啊，深刻理解运维人员的辛苦……）  </p>
<p>因此，在coordinator中，打算7月26日凌晨4点跑的任务，在<code>coordinator-app</code>的<code>start</code>属性就要设置成<code>2016-07-25T20:00Z</code>，如果本身就是处理头一天的数据（即7月25日），并且输出结果的路径按日期进行拼接，则在<code>coordinator.xml</code>的<code>action</code>中就可以指定<code>workflow.xml</code>的路径，同时把日期以变量的形式传入<code>workflow.xml</code>，具体如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">workflow</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">app-path</span>&gt;</span>$&#123;wf_app_path&#125;<span class="tag">&lt;/<span class="name">app-path</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>analysisDate<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;coord:formatTime(coord:nominalTime(),'yyyy-MM-dd')&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">workflow</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>很多时候，因为时区问题会让处理变得比较麻烦，需要灵活使用oozie的EL常量。如下：<br><code>&lt;value&gt;${coord:formatTime(coord:dateOffset(coord:nominalTime(), -1, &#39;DAY&#39;), &#39;yyyy-MM-dd&#39;)}&lt;/value&gt;</code></p>
<h4 id="XML-Schema日期时间"><a href="#XML-Schema日期时间" class="headerlink" title="XML Schema日期时间"></a>XML Schema日期时间</h4><p>有时候经常看到打印的结果是这种格式：<code>2002-05-30T09:30:10Z</code>， 有日期，有时间没问题。那么其中的<strong>T</strong>和<strong>Z</strong>代表什么含义呢？<br>这其实是标准XML Schema的日期时间数据格式。其具体的格式是这样的：<br><code>&quot;YYYY-MM-DDThh:mm:ss&quot;</code> </p>
<ul>
<li><code>YYYY</code> 表示年份</li>
<li><code>MM</code> 表示月份</li>
<li><code>DD</code> 表示日</li>
<li><code>T</code> 表示必需的时间部分的起始</li>
<li><code>hh</code> 表示小时</li>
<li><code>mm</code> 表示分钟</li>
<li><code>ss</code> 表示秒  </li>
</ul>
<p>比如：<code>&lt;startdate&gt;2002-05-30T09:00:00&lt;/startdate&gt;</code><br>在日期或时间的结果加<strong>Z</strong>表示时区<code>(TimeZone)</code>，如果单纯一个Z，表示使用世界协调时间(UTC)，默认的是0时区。当然，也可以通过在时间后添加一个正的或负时间的方法，来规定以世界调整时间为准的偏移量。比如这样：<br><code>&lt;start&gt;09:30:10+06:00&lt;/start&gt;</code><br><code>&lt;start&gt;09:30:10-06:00&lt;/start&gt;</code></p>
<p>先写到这里吧，有更多实践的时候再补充。  </p>
<blockquote>
<p>如果本文有出于我个人理解或表达的错误，还望指正。<br>如果本文有涉及到版权、知识产权的问题，请及时与我联系。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的抽象类和接口]]></title>
      <url>https://FergusChen.github.io/2016/08/16/Java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>写这篇文章，是想从面向对象设计的角度出发，去探讨抽象类和接口。也是对抽象类和接口要点的总结。<br><a id="more"></a></p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>我们知道，抽象是面向对象的四大特性之一。我们从现实世界的事物中可以抽象出事物的属性和功能。通过分析不同的事物，发现彼此之间可能存在很多不同的关系，比如层次的继承关系、部分与整体强相关的组合关系、部分与整体弱相关的聚合关系等等。其中，将事物的共性（属性和方法）抽取出来，就形成父子继承关系。在这个过程中，有些方法是有默认实现的，就可以在父类中定义方法体（尽管子类可以覆盖）。但有些只知道有此方法，根本不知道子类会如何实现。这时候，抽象类就派上用场了。<code>注意：抽象类描述的仍是继承关系。</code>  </p>
<p>抽象类用于定义所有子类共同的、但不确定如何实现的成员方法。Java中抽象类的使用有如下要点：</p>
<ul>
<li>抽象方法必须定义在抽象类中；</li>
<li>抽象类和抽象方法都必须被abstract关键字修饰；</li>
<li>抽象类不能被初始化。解释的话，知乎上的一个回复也很贴切：周星驰的电影中那个去水果店，揪住老板说要一斤水果！老板问他你要什么水果，他说他就要水果！这个水果就是抽象类，你如果能在水果店买到一斤叫水果的水果，那就能实例化一个抽象类。</li>
<li>抽象类的方法必须在子类中被覆盖才能使用；</li>
<li>抽象类中既可以有抽象方法，也可以定义具体的成员变量和成员方法。除了具有抽象方法之外，其它的跟普通类一样定义；</li>
<li>一旦子类继承了某个抽象类，则抽象类中的抽象方法必须在子类中被覆盖；</li>
<li>若某个类要继承抽象类，同样使用<strong>extends</strong>关键字，而且是单继承。即一个类只能继承一个抽象类。  </li>
</ul>
<p>一个抽象类的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"my name:"</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口是对外暴露的一系列方法的声明，用于对类进行扩展。接口的本质是一系列规范，<code>在Objective-C中甚至没有接口（Interface），而是叫协议（protocol）</code>。理解这一点，就好像主板上对外提供各种接口，有USB接口、SATA硬盘接口、PCIE接口等。尽管不同的主板可以将接口的颜色换一下，位置换一下。但是各类接口的尺寸、针脚等都是固定的，是早先定义的规范。  </p>
<p>在面向对象设计中，接口就是预先定义的规范。当定义了一个接口，仅仅说明了此接口能<strong>做什么</strong>，没有定义<strong>如何做</strong>。如果一个类实现此接口，就立刻知道了这个类能<strong>做什么</strong>，至于<strong>如何做</strong>，是在类内部定义的。</p>
<p>Java中接口用得非常广泛，比如<strong>Comparable接口</strong>定义的规范是：两个对象可以比较。但如何比较取决于对象内部的实现。比较String和Number都不是问题，但比较两个自定义对象时，是按照哪个字段进行比较，就要在类内部实现了。如Student类可以按照姓名比较，也可以按照学号比较等。  </p>
<p>Java中接口的使用有如下要点：  </p>
<ul>
<li>接口是用于对类进行扩展的。若某个类实现了一个接口，就证明该类具有此接口定义的所有方法。</li>
<li>接口中可以定义两类元素：常量和抽象方法；<code>注意：接口中的方法都是public的。</code></li>
<li>接口中的常量默认都是public static final的。尽管如此，显式声明可以提高代码可读性；</li>
<li>接口中的方法默认都是public abstract的，尽量显式声明；</li>
<li>接口不能被初始化，但可以通过接口名调用接口中的常量；</li>
<li>java中支持多实现。即一个类可以实现多个接口。</li>
<li>若某个类要实现接口，使用<strong>implements</strong>关键字。    </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Pocket</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SIZE = <span class="number">20</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getSome</span><span class="params">()</span></span>;</div><div class="line">    <span class="keyword">int</span> MAX_COUNT = <span class="number">5</span>; <span class="comment">//合法，但不友好，尽量添加public static final修饰</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pubSome</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，接口也可以被继承，但只能被接口继承，甚至可以在接口之间实现多继承。因为接口中的方法只是声明，而具体的实现是在实现此接口的类中。若两个接口中有签名完全相同的方法，一个类实现了这两个接口，只要将接口中声明的这个方法实现了就行，无所谓这个方法是来自哪个接口。<code>注意，不要在不同的接口定义方法名和参数列表都相同，但返回值不相同的方法，这样的设计很糟糕。</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showA</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showB</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;  <span class="comment">//必须实现接口A和接口B的所有方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showA</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showB</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="抽象类和接口的比较"><a href="#抽象类和接口的比较" class="headerlink" title="抽象类和接口的比较"></a>抽象类和接口的比较</h4><p>具体使用要点的比较就不多说了，上面都有。  </p>
<p>不过，有的人觉得既然抽象类已经可以定义抽象方法，类可以继承并实现此方法。接口也是定义抽象方法的，而且接口还不能定义成员变量和有实现的成员方法，比抽象类的功能还弱。为什么有抽象类了还需要接口呢？就说接口可以多实现，抽象类只能单继承，但如果Java某一天支持多继承了，是不是接口就没有存在的意义了呢？  </p>
<p>其实，这样的问题只是从两者功能实现的相似性考虑问题了。然而，看到本质，还是面向对象设计思想。抽象类描述的是<strong>继承</strong>的关系，而接口则是对类的扩展，可以描述<strong>聚合</strong>或<strong>组合</strong>的关系。这个是有很大区别的。比如知乎的鱼鱼鱼举的一个例子就很贴切：</p>
<blockquote>
<p>苹果和鸡都可以吃，但是苹果是水果，鸡是动物，这个时候可以通过实现 edible 这个接口。所以说，“接口比类带来更多的灵活性”。   </p>
</blockquote>
<p>尽管实际开发中很多功能两者都可以实现，但是良好的实现是取决于良好的面向对象设计思想。这一点也很重要。  </p>
<p>如果对于抽象类和接口比较迷糊，可以到知乎的一个问题上看看，瞬间会清晰很多。<a href="https://www.zhihu.com/question/20111251" target="_blank" rel="external">Java 中的接口有什么作用？</a>   </p>
<p>若感觉文章中有什么问题，欢迎一起讨论，或者可以帮我指正。非常感谢~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java中的继承]]></title>
      <url>https://FergusChen.github.io/2016/08/14/java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p><strong>继承</strong>是面向对象设计的四大特性之一。从表面上看，继承关系就是“父子”关系。子类可以继承父类非私有的成员变量和成员方法。换句话说，在父类中已经定义的成员变量和成员方法，子类可以直接使用，而不必重新定义。那么，在java中，继承是如何体现的呢？在使用继承关系时，又有哪些要点呢？在这篇文章就简单总结一下。<a id="more"></a>  </p>
<hr>
<p>首先说继承。如果仅仅说继承就是“父子”关系，其实不太全面。准确来说，继承描述的是对象之间的<strong> “is a” </strong>关系。 举例来说：学生是一个人；牡丹是一种花；鹦鹉是一种鸟…… 这样的关系简直是太常见了。  </p>
<p>在java中实现继承可以更清楚地展现类之间的关系，易于维护。这也是面向对象设计的优点。同时，继承可以提高代码的复用性，提高项目的可扩展性等等。<code>注意：一定不能为了复用代码而随便继承。</code>代码实现是基于设计的，没有“is a”关系的类，就不要建立继承关系。</p>
<hr>
<p>java中继承用<strong>extends</strong>关键字。子类中可以直接使用父类的成员变量和成员方法，同时也可以重新定义成员变量和成员方法（<em>覆盖</em>）。在子类中，关键字<strong>this</strong>指向当前的类，关键字<strong>super</strong>指向父类。如下：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"my name:"</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line">    String university;</div><div class="line">    <span class="comment">//覆盖父类的成员方法</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.speak();</div><div class="line">        System.out.println(<span class="string">"my university:"</span>+ <span class="keyword">this</span>.university);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"I should study hard, because it's my duty"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"I should work hard, because it's my duty"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="成员变量的继承"><a href="#成员变量的继承" class="headerlink" title="成员变量的继承"></a>成员变量的继承</h3><p>子类可以继承父类非私有的成员变量，也可以在子类中覆盖父类的成员变量。在子类中，使用this调用子类的成员变量，使用super调用父类的成员变量。  </p>
<h3 id="成员方法的继承"><a href="#成员方法的继承" class="headerlink" title="成员方法的继承"></a>成员方法的继承</h3><p>子类可以继承父类非私有的成员方法。同时子类可以覆盖父类的成员方法（如上例Student类中是speak方法）。继承中的这个特性让项目更易于扩展。具体来说，就是项目中同样的方法需要有新的实现时（<em>比如：来电显示中以前只显示号码和姓名，现在要添加归属地和头像的显示；播放视频时以前只是单纯地播放，现在要在视频右上角显示当前时间等等。需求变更、添加功能是很常见的</em>）。若项目已经上线，或进入后期阶段，则直接修改原来的父类或子类的代码，将是一个灾难。因为可能很多地方都用到了这个类，要改的话，可能会改一堆……<br>所以，最好的办法就是使用继承，并在新类中覆盖需要重写的方法。在重写该方法时，可以用super调用父类的方法，在此基础上扩展新功能。以后只需要new新类，就可以调用新的功能。<br>当然，若要覆盖父类的成员方法，需要以下两个条件：</p>
<ol>
<li>子类中，该方法的访问权限要大于或等于父类的方法。我们知道java中访问权限有4种：<strong>public、private、protected和default</strong>。上个例子中没有任何修饰符，就是default权限。<strong>default</strong>的访问级别介于public和private之间。若父类中是default权限，子类只能是default、protected或public，不能是private。<code>注意：如果是父类中有个A方法是private修饰的，那么，在子类中就算有一个方法与A方法签名完全相同，也不算方法覆盖，而是子类中的新方法。</code>因为在子类，该方法本身不可见。这里，覆盖的说法没意义。</li>
<li>静态方法只能覆盖静态方法，不能覆盖非静态方法。因为静态和非静态的加载时机不一样，存储位置也不一样。静态的成员变量和成员方法都是类加载的时候就加载进入内存，而非静态是创建对象时加载。  </li>
</ol>
<h3 id="继承中的构造方法"><a href="#继承中的构造方法" class="headerlink" title="继承中的构造方法"></a>继承中的构造方法</h3><p>构造方法和类同名，当然没有继承的说法。但是，在继承中，构造方法的调用时机需要说明一下。<br><strong>子类的所有构造方法，都会先执行父类的默认构造方法，然后才执行子类构造方法中的其它语句。</strong>也就是说，在子类的构造方法中都会隐式地插入这样一句代码：<code>super();</code>（子类构造方法中先用<code>this()</code>调用其它构造方法的除外，因为在<code>this()</code>中已经调用了父类的构造方法）<br>因为在子类其实包含父类的成员变量，但这些成员变量的初始化是在父类中定义的。因此，初始化子类时一定要先调用父类的构造方法初始化这些成员变量。<br>当然，子类的构造方法中也可以手动指定调用父类的哪个构造方法，但一定要先调用父类的构造方法。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>说了这么多，继承的确有很多好处，但是继承却破坏了对象的封装性。在java中，为了解决这个问题，可以使用final关键字。<br>final关键字可以修饰类、变量、方法等，只要被final修饰，就不能再被修改。具体来说，final修饰的类不能被继承；final修饰的方法不能被覆盖；final修饰的变量就是一个常量了。<strong>ps：</strong>可以在类中定义全局静态常量，用类名就可以直接访问，如下：<code>public static final double PI = 3.14159;</code></p>
<p>好了，先记这些吧，以后有新的见解再补上。</p>
<p>若文章中有问题，欢迎指正。</p>
]]></content>
    </entry>
    
  
  
</search>
