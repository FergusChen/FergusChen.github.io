<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Scala中的Option、None、Nothing、Null和Nil]]></title>
      <url>https://FergusChen.github.io/2016/08/22/Scala%E4%B8%AD%E7%9A%84Option%E3%80%81None%E3%80%81Nothing%E3%80%81Null%E5%92%8CNil/</url>
      <content type="html"><![CDATA[<p>在Scala中有几个容易混淆的类型，像是None、Nothing、Null、Nil等。在实际编程中又经常会遇到。要有一个清楚区分，这边文章就简单做个总结。<br><a id="more"></a>  </p>
<p>首先可以参考一下scala的继承层次树：<br><img src="http://oc5u7idl7.bkt.clouddn.com/scala%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1.png" alt="scala中的Null" title="scala继承层次树"></p>
<p>可以看到，在Scala中，所有类型的父类是Any，其声明了isInstanceOf、asInstanceOf、equal、hashCode、toString等方法。<br><strong>Any</strong>有两个直接子类：AnyVal和AnyRef。<br><strong>AnyVal</strong>是所有值类型的父类，没有追加任何方法，只是所有值类型的一个标记。<br><strong>AnyRef</strong>是所有引用类型的父类，追加了来自Object类的wait、notify等监听方法。<br>所有Scala类都实现了ScalaObject这个标记接口，该接口只是一个标记，没有定义任何方法。  </p>
<p>在这个继承层次树中的底端，有两个特殊的类型：Null和Nothing<br><strong>Null</strong>只有一个实例，就是null值。我们可以将null赋值给任何引用类型，但不能赋值给值类型。<br><strong>Nothing</strong>是任意类型的子类。Nothing类没有实例，但可以表示任意类型。所以经常用于泛型结构，如空列表Nil的类型就是List[Nothing]，它是List[T]的子类型，T可以是任何类。</p>
<p>接下来对其它的几个类型做说明：</p>
<p><strong>Unit</strong>类型相当于java中的void，其只有一个值，就是()。Unit只是AnyVal的子类，但编译器允许任何值被替换成()</p>
<p><strong>None</strong>类型是Option类的子类，代表不存在的值（non-existent）  </p>
<p><strong>Some[A]</strong> 类型也是Option类的子类，代表类型A存在的值。</p>
<p><strong>Option</strong>代表一个可选的值。既可以是Some[A]的一个实例，也可以是None，即不存在。scala推荐在可能返回空对象的函数中，声明返回值为Option[A]。Option类型中也提供isEmpty，get，getOrElse等方法来操作和判断。</p>
<p><strong>Nil</strong>是一个空的List，其相当于List[Nothing]。  </p>
<blockquote>
<p>如果本文有出于我个人理解或表达的错误，还望指正。<br>如果本文有涉及到版权、知识产权的问题，请及时与我联系。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在线广告的发展过程]]></title>
      <url>https://FergusChen.github.io/2016/08/19/%E5%9C%A8%E7%BA%BF%E5%B9%BF%E5%91%8A%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>　计算广告已经成为当下十分热门的话题。但是，要 真正了解计算广告，仅仅从一些计算公式、业务规则等入手，还是很受局限的。因为广告行业对我们来说都不陌生，而在线广告也从传统的合约广告到定向广告，再到现在的竞价广告，经历了多次变革，每一步都在广告效果、广告收益等方面有很大的革新。因此，要了解计算广告，最好的办法就是了解整个在线广告的发展历程。下面就从广告的定义入手，简要介绍在线广告的发展过程。<br><a id="more"></a></p>
<blockquote>
<p>全文引自刘鹏、王超著的《计算广告·互联网商业变现的市场与技术》  </p>
</blockquote>
<h4 id="什么是广告？"><a href="#什么是广告？" class="headerlink" title="什么是广告？"></a>什么是广告？</h4><p>引用Willianm F. Arens在《当代广告学》中给出的定义：<br><em>广告是由已确定的出资人通过各种媒介进行的有关产品（商品：服务和观点）的，通常是有偿的、有组织的、综合的、劝服性的非人员的信息传播活动。</em><br>这一定义中有两个关键点，首先，它指出了广告活动的两个主动参与方：<strong>出资人</strong> (sponsor) 和<strong>媒体</strong> (medium)。这其实是广告行业的两个最基本的角色<code>（还有一个被动的角色就是受众）</code>。其实说白了，这两个角色就是：需求方（demand）和供给方（Supply）。<br>这里的需求方可以是广告主(advertiser)、代表广告主利益的代理商（agency）或其他技术形态的采买方；这里的供给方可以是媒体，也可以是其他技术形态的变现平台。另外，要特别注意的是，广告还有一个被动的参与方，即受众（audience）。  </p>
<p>请大家从现在开始就牢牢建立起这样的概念：<code>出资人、媒体和受众这三者的利益博弈关系是广告活动永远的主线</code>，这一主线将贯穿于商业和产品形态的整个演化过程。另外，该定义还阐明了广告必须是有偿的、非人员的信息传播活动。这两点限制，前者使得广告的目标变得明确，后者使得过这一目标可以采用计算的方式来优化，而这些都是计算广告产生的基础。  </p>
<h4 id="广告的目的是什么？"><a href="#广告的目的是什么？" class="headerlink" title="广告的目的是什么？"></a>广告的目的是什么？</h4><p>广告这一商业行为，其本质目的是什么呢？在不同的时代，广告主与媒体对这一问题存在着不同的认知。在传统媒体时代供给方与需求方在市场地位上有相当的距离，不论你运营的是电视台、机场或杂志都与大多数广告主需要的转化行为之间有相当大的差距。因此这一阶段广告的目的是希望借助媒体的力量来快速接触大量用户以达到宣传品牌形象、提升中长期购买率与利润空间的目的。这种目的的广告称为<code>品牌广告</code>（brand awareness)。当然，也有许多广告商希望能利用广告手段马上带来大量的购买或其他转化行为。这种目的的广告称为<code>直接效果广告</code>（direct Response）。 有时也简称为<code>效果广告</code>。  </p>
<p>仍然引用Willianm F. Arens在《当代广告学》中给出的见解：<br><em>广告的根本目的是广告主通过媒体达到低成本的用户接触。</em>  </p>
<p>也就是说，按某种市场意图接触相应的人群，进而影响其中的潜在用户，使他们选择广告主产品的几率增加，或者对产品性价比的苛求程度降低，这才是广告的根本目的。至于短期内的转化效果，由于市场意图或媒体性质的不同，并不是直接可比。换句话说，如果仅仅以转化效果为目的来思考问题可能会背离投放广告的正确方法论。举个例子，某感冒药广告商如果以短期效果为导向那么最佳的策略是把广告投放给那些现在感冒的人。不过这显然是一个荒谬的决策；再比如某汽车广告商为了提升自己的品牌形象，希望对自己竞品品牌的用户加强宣传，而对于这部分人群，广告的直接效果甚至有可能比随机投放还要差。  </p>
<h4 id="在线广告简史"><a href="#在线广告简史" class="headerlink" title="在线广告简史"></a>在线广告简史</h4><p>在讨论广告技术之前，我们先浏览一下在线广告发展的历程。因为广告市场的概念、技术和术语繁多，如果不是对这些有基本的了解，很难深入探讨具体的产品。回到20世纪末，那时的在线媒体（如AOL、Yahoo!等网站）刚刚产生不久。他们已经取得了不错的流量规模。可是投资人当然希望这些媒体也能够给他们带来真金白银。要对这些线上流量进行变现，最直接的方法就是把网站的HTML页面当成杂志的版面，在里面插入广告位。供给方有了，那么需求方呢？线下的广告代理公司也就把这些网站当成一本本新的杂志，按原来的思路和逻辑进行采买。这种在互联网上展示广告创意的产品形式称为 <code>展示广告
(display advertising)</code>，也叫显示广告。这一阶段的展示广告售卖模式称为<code>合约广告(agreement-based advertising)</code>。即采用<strong>合同约定</strong>的方式确定某一广告位在某一时间段为某特定广告主所独占，并且根据双方的要求，确定广告创意和投放策略。当然，这样的采买模式还没有对计算的需求，因为此时唯一需要的就是把广告主的创意作为一个HTML的片段插入到媒体的页面中。然而，情况变化很快，互联网媒体为了营收的增长，希望逐年甚至逐季提高自己的广告位报价。在流量快速增长或者数字广告逐渐为广告主认知的阶段，提价是比较容易被市场接受的。可是当媒体的流量和品牌认知度都相对稳定以后，又有什么新的提高收入的办法呢？  </p>
<p>互联网广告运营者们经过探索，很快就发现了在线广告不同于传统媒体广告的本质特点： <strong>我们可以对不同的受众呈现不同的广告创意</strong>！在今天看来再平常不过的这个观念，实际上是在线广告的效果和市场规模不断发展的核心驱动力。认识到这一点，媒体找到了一条能使广告位报价继续提高的思路。例如，可以把某广告位的男性受众和女性受众卖给不同的广告主，比如对男性受众展示某剃须刀品牌的广告，而对女性受众展示某化妆品品牌的广告，这样的广告投放方式称为<code>定向广告（targeted advertising）</code>。很显然，这样的广告系统已经对计算技术产生了两个具体需求：一是<code>受众定向（audience targeting)</code>，即通过技术手段标定某个用户的性别、年龄或其他标签；二是<code>广告投放（ad serving）</code>，即将广告投送由直接嵌入页面变为实时响应前端请求并根据用户标签自动决策和返回合适的广告创意。由于从传统的品牌广告延伸而来，此时的定向广告仍然以合约的方式进行。媒体向广告主保证某个投放量，并在此基础上确定合同的总金额以及投放量未完成情况下的赔偿方案。这种<code>担保式投送(Guaranteed Delivery, GD )</code>的交易方式逐渐成为互联网合约式广告的主要商业模式。一般来说，这样的合约仍然主要面向品牌广告主，并且遵循按<code>千次展示付费（Cost per Mille, CPM）</code>的计费方式。  </p>
<p>合约广告系统中有一个重要的计算问题，即在满足各合约目标受众量要求的同时尽可能为所有广告商分配到质更好的流量。这一问题有两个难点：一是如何有效地将流量分配到各个合约互相交叉的人群覆盖上；二是要在在线的环境下实时地完成每一次展示决策，这个问题称为<code>在线分配(online allocation)</code>。 如果将各合约的量看作约束条件，将某种度量下的质看作目标函数，可以利用<code>带约束优化(constrained optimization)</code>的数学框架来探索这一问题。为了得到在线环境下切实可行的解决方案，学术界和工业界的同仁在理论和工程方面进行了大量的研究，有一些高效且简便的实用方案已经为各媒体广泛采用。  </p>
<p>需要注意，展示广告领域定向投放的最初动机是供给方为了拆分流量以获得更高的营收，如果一开始就提供非常精细的定向，反而会造成售卖率的下降。因此，最初的定向标签往往都设置在较粗的粒度上，最典型的是一些人口属性标签。受众定向显然更符合需求方的口味和利益——不要忘了，广告市场的钱全部是来自需求方的，他们的利益被满足得越好，市场的规模就会越大。因此，受众定向产生以后，市场向着精细化运作的方向快速发展。这一发展主要有两方面的趋势：一是定向标签变得越来越精准；二是广告主的数量不断<br>膨胀。在这些趋势下，仍然按照合约的方式售卖广告会遇到越来越多的麻烦。首先，很难对这些细粒度标签组合的流量做准确预估；其次，当一次展示同时满足多个合约的时候，仅仅按照量约束下的在线分配策略进行决策有可能浪费掉了很多本来可以卖得更贵的流量。既然量的约束带来了这些麻烦，有没有可能抛弃量的保证而采用最唯利是图的策略来进行广告决策？这样的思路催生了计算广告历史上革命性的产品模式——<code>竞价广告（auction-based advertising)</code>。在这种模式下，供给方只向广告主保证质，即单位流量的成本。但不再以合约的方式给出量的保证。换言之，对每一次展示都基本按照收益最高的原则来决策。  </p>
<p>上面是从展示广告的发展看竞价产生的原因，实际历史的足迹却并非如此。竞价广告产生的最初场景是在互联网广告最主要的金矿——搜索广告（search ad）中。在以Google为代表的搜索引擎在技术成熟以后，迅速成为互联网新的入口。与门户网站不同，搜索引擎从一开始就没有被当作媒体来看待，因此搜索流量的变现也采用了与服务自然结合的<code>付费搜索(paid search 或 sponsored search)</code>模式。从广告的视角来看，也可以把付费搜索看作种定向广告，即根据用户的即时兴趣定向投送的广告，而即时兴趣的标签就是关键词。很显然，这种定向广告从一开始就直接达到了非常精准的程度也就很自然地采用了竞价的方式售卖。  </p>
<p>搜索广告产生了巨大的收益以后，搜索引擎开始考虑将这样的变现方式推广到其他互联网媒体上：将用户的即时兴趣标签由搜索词换成正在浏览页面中的关键词，可以将这套竞价广告系统从搜索结果页照搬到媒体页面上，这就产生了<code>上下文广告(contextual advertising)</code>。上下文广告的初期，创意的形式也是与搜索广告一样的文字链接，许多产品讨论将它与展示广告分开对待，不过当我们把它与上一段中精细化定向的展示广告对比来看时就知道，这样的区分实际上没有必要，或许从创意形式上把展示广告和文字链广告区别开更符合分类的逻辑。  </p>
<p>从宏观市场上看，竞价广告与合约广告有很大的不同。没有了合约的保证，大量的广告主处在一个多方博弈的环境中。与直觉不同的是，在如何收取广告主费用这一点上，我们并非按照微观上最优的方案实施就可以达到整个市场最大的收益。关于定价机制的深入研究，产生了<code>广义第二高价(Generalized Second Price, GSP)</code>这一竞价重要的理论。  </p>
<p>基于竞价机制和精准人群定向这两个核心功能，在线广告分化出了<code>广告网络（ad Network, ADN）</code>这种新的市场形态。它批量地运营媒体的广告位资源，按照人群或上下文标签售卖给需求方，并用竞价的方式决定流量分配。广告网络的结算以按<code>点击付费(Cost per Click，CPC)</code>的方式为主，这一点有数据和业务方面多层次的原因，在本书的后面会详细探讨。虽然我们不太能指这种方式的<code>千次展示收益(Revenue per Mille, RPM)</code>可以达到合约式品牌广告的水平，但它使得大量中小互联网媒体有了切实可行的变现手段：这些媒体有一定的流量，但还不值得建立自己的销售团队面向品牌广告商售卖，直接把自己的广告<code>库存(inventory)</code>托管给ADN，借助ADN的销售和代理团队为自己的流量变现。  </p>
<p>ADN既然只通过出价接口提供价格约定，那么由谁来保证量呢？自然会有需求方的某种产品来完成。当ADN产生以后，代理公司当然也要对广告采买方式做出调整，因为此时的流量采买发生了几点显著变化：一是更多地面向受众而非媒体或广告位进行采买，这当然是与受众定向的流行有直接关系；二是需求方的代理需要采用技术的手段保证广告主量的要求，并在此基础上帮助广告主优化效果，这又是一个与在线分配类似的带约束优化问题。但是，实际上这个问题有着本质的不同：由于只能在ADN定义好的定向标签组合上预先指定出价，而不能控制每一次展示的出价，因此，市场看起来像一个黑盒子，需求方只能靠选择合适的标签组合以及阶段性调整出价来间接控制效果。这种面向多个ADN或媒体按人群站式采买广告并优化投入产出比的需求方产品，我们称为<code>交易终端（Trading Desk, TD）</code>  </p>
<p>在ADN中，核心的竞价逻辑是封闭的，这不能满足需求方越来越明确的利益要求。试想下面两个例子（1）某电子商务网站需要通过一次广告投放来向它的忠实用户推广某产品；（2）某银行希望通过自己的信用卡用户在网络上找到类似的潜在用户群，并通过广告争取这批潜在用户。很显然，AND很难直接为这两个需求提供人群标签。定制化需求催生了一种开放的竞价逻辑，让需求方按自己的人群定义来挑选流量，这就是<code>实时竞价(Real Time Bidding，RTB)</code>，它是将拍卖的过程由广告主预先出价，变成每次展示时实时出价。只要把广告展示的上下文页面URL以及访客的用户标识等信息传给需求方，它就有充分的信息来完成定制化的人群选择和出价。于是，市场上产生了大量聚合各媒体的剩余流量并采用实时竞价方式为他们变现的产品形态——<code>广告交易平台(ad Exchange，ADX)</code>。这个名称让我们很容易联想起股票交易所。事实上，如果我们把ADN的交易方式想象成场外交易市场(over-the-counter market)， 那么ADX与股票交易所确实有着类似的作用。  </p>
<p>通过实时竞价的方式，按照定制化的人群标签购买广告，这样的产品就是<code>需求方平台(Demand Side Platform, DSP)</code>。由于实时竞价主要采用按展示次数计费的方式（本书后面部分会具体讨论其原因），DSP需要尽可能准确地估计每一次展示带来的期望价值。在这点上，DSP比TD要方便多了，因为充分的环境信息使得深入的计算和估计成为可能，基于DSP的广告采买非常类似于股票市场上的程序交易，我们把这样的广告采买方式也叫作<code>程序化交易(programmatic trade)</code>。除了RTB以外，还有其他几种程序购买的交易方式，如<code>优选(prefered deals)</code>以及<code>私有交易市场（Private Market Place， PMP ）</code>等。可以预见，在线广告中程序化交易的作用和地位将会不断加强，这是由数字广告的本质特点以及广告主利益最大化的趋势所决定的。  </p>
<p>由于在线广告存在着较为复杂的市场结构，LUMA Partners对北美市场的主要代表公司进行非常全面的总结，并绘制成了下图中的“display LUMAscape”。  </p>
<p><img src="/images/display-lumascape-2014.jpg" alt="display-lumascape"></p>
<p>这一图谱的骨架与上面我们介绍的在线广告简史有着非常紧密的联系，因此也是本书在广告产品方面重要的提纲。基本上可以说，这一图谱是从两端向中间逐渐发展和形成的：首先是合约阶段，广告主通过代理公司从媒体方采买广告，而媒体方的广告投放机则负责完成和优化各个广告主的合约；然后，市场进化出了竞价售卖方式从而在靠近供给方产生了ADN这样的产品形态，而需求方的代理公司为了适应这一市场变化，孵化出了对应的<code>媒介采买平台(media buying platform)</code>； 最后，当市场产生了实时竞价方式交易时，供给方进化出了ADX，而需求方则需要用DSP与其对接来出价和投送广告。图中的下半部分多是一些对这一骨干市场结构起支持作用的产品或者在细分领域的特异化产品。我们在后面介绍到相关部分时将会给出相应的介绍。  </p>
<p>总结一下，在在线广告发展的历史上，定向技术和交易形式的进化是一条主线。从最初的固定位置合约交易发展到进行受众定向、按展示量结算的合约交易再到竞价交易方式，并最终发展成开放的实时竞价交易市场。这条主线的核心驱动力是让越来越多的数据源为广告决策提供支持，从而提升广告的效果。除了这条交易形态的主线，互联网广告产品还有另外一条发展线路，即产品展现逻辑上的发展：在展示广告的最初阶段，广告位作为与内容相对独立的单元来决策和运营，并且完全以优化收入为目标；但同时人们从搜索广告和社交网络信息流广告中得到了启发——将内容与广告对立起来未必是一个好的选择。搜索广告和社交网络信息流广告这两种广告产品正是由于与内容的展现和触发逻辑有着高度的一致性，才使得它们的效果突出。沿着这样的思路，将内容与广告以某种方式统一决策或排序的广告产品——<code>原生广告（Native AD）</code>在近年来得到了工业界越来越多的关注。如何将原生的决策方式与前面介绍的广告市场已经非常成熟的规模化交易逻辑相结合是目前互联网广告产品发展的热点。需要特别说明的是，原生广告的思路在移动设备这样屏幕尺寸受限的环境下将会成为一个非常有前景的发展方向，这方面的进展我们将在第7章中具体讨论。  </p>
<blockquote>
<p>以上内容基本上完全摘自刘鹏、王超著的《计算广告·互联网商业变现的市场与技术》。这本书介绍得非常清晰，对上文中提到很多概念也做了详细的解释。若要深入了解计算广告，可以在这本书中查阅。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[.gitignore不起作用的解决方案]]></title>
      <url>https://FergusChen.github.io/2016/08/18/gitignore%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>.gitignore文件的作用是让git在版本控制时忽略一些文件，知道哪些文件不需要添加到版本库中，像是jar包、.iml项目文件等等。但有时候发现明明在.gitignore忽略的文件，还会出现在版本库中，.gitignore好像无效了，不起作用！！！ 这里就简单说明一下问题的原因。<br><a id="more"></a>  </p>
<p>首先说下<strong>.gitignore文件</strong>。虽然使用git可以对任何文件进行版本控制，包括源代码、二进制文件、配置文件、甚至视频等多媒体文件。但是，通常在项目中不需要对某些文件进行版本控制。比如jar文件，有的jar文件甚至有100多兆，而且每次编译都会重新生成，也根本没必要进行版本控制。所以，定义.gitignore文件还是很有必要的。  </p>
<p>.gitignore文件跟.git在同级目录下，通常在项目的根目录下。在git init初始化时，会生成.git文件夹（隐藏的），<strong>但默认是不会生成.gitignore文件的</strong>。所以，需要手动添加.gitignore文件，然后可以参考这个项目，确定哪些文件可以被忽略：<a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a>  </p>
<p>出现.gitignore文件无效的原因就是，在git初始化时，忘记添加.gitignore文件了。已经add commit push过了之后，才添加.gitignore文件。<code>.gitignore文件只对还没有加入版本管理的文件起作用，已经添加到版本管理中的文件，.gitignore也不会负责删除。</code>  </p>
<p>这样的话，只能手动删除缓存中的文件，然后再add、commit、push。运行如下命令：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git rm --cached .</div><div class="line">git add .</div><div class="line">git commit -m &quot;gitignore重新配置&quot;</div></pre></td></tr></table></figure>
<p>之后，.gitignore就起作用了。注意每次修改.gitignore都需要清除缓存啊。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编程中的时区和时间]]></title>
      <url>https://FergusChen.github.io/2016/08/17/%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%97%B6%E5%8C%BA%E5%92%8C%E6%97%B6%E9%97%B4/</url>
      <content type="html"><![CDATA[<p>在开发过程中常常会碰到时区的问题。有时候明明要获取当前时间，但结果却倒流了8个小时。在打印时间时，也会出现UTC、GMT等后缀。这些关键字都代表什么意思？在开发中应该怎么处理呢？这里就做一个简要的总结。<br><a id="more"></a>  </p>
<p>我想从时区的简要介绍开始，讨论一下我所遇到过的时区处理问题。<br>由于地球的自转周期是24小时，人们就将地球按经度划分为24个时区。这样，以英国伦敦格林威治天文台的经线（本初子午线）为零时区中心线，向东向西各12个时区。每个时区15度（360/24），这样相邻两个时区的时区中心线就正好相差1个小时。北京位于东八区，地球自西向东自转，北京就比伦敦早8个小时。换句话说，北京的中午12点，伦敦还是凌晨4点。注：有时候北京比伦敦早7个小时，是因为伦敦施行日光节约时制（DST）具体可以google。<br><img src="http://oc5u7idl7.bkt.clouddn.com/timezone.gif" alt="时区图">  </p>
<p><strong>GMT</strong>：Greenwich Mean Time，即格林威治标准时间，又叫世界时。GMT是以地球自转为基础的时间计量系统。该系统源自于十七世纪成立的英国格林威治皇家天文台，其观测所门口墙上有一个标志24小时的时钟，天文学观测将每日太阳穿过本初子午线的瞬间定为正午时刻。此后，全世界都以GMT时间作为标准时间参考点，根据时区差可以方便地计算当地时间（有时候看到GMT + 8就是这样换算）。但是，因为地球在椭圆轨道运行，其自转是不规则的，所以，GMT时间可能与实际的太阳时会有偏差。所以，从1924年，格林威治天文台每隔1个小时就向全世界发放调时信息。直到后来，有UTC的存在，GMT时间就不再作为世界标准时间。  </p>
<p><strong>UTC</strong>：Coordinated Universal Time，即协调世界时间，又叫世界标准时间。是以原子时秒长为基础的时间度量系统。UTC在时间上尽量接近于世界时（GMT），其计算过程非常严谨精密。并且UTC时间的精确度高，每日保持与世界时不超过0.9秒的误差。若因为地球自转不均匀而导致原子时和世界时误差变大时，UTC就通过加上正或负的闰秒来补偿，这个由位于巴黎的国际地球自转事务中央局负责。目前，UTC已经作为万维网的标准，广泛应用于计算机系统中了。  </p>
<p>还有很多时间标准，像是DST、原子时、太阳时、恒星时等，这里就不多讨论了。就是GMT、UTC，若要展开介绍其计算方法、发展历程、应用范围等，内容还是非常多的。但作为程序员，不搞天文地理，没必要太深入。还是简单了解一下，然后就开始应用吧。<br>ps：综上所述，若不追求太精确，GMT和UTC时间是一样的。但实际应用中都有时区的问题。  </p>
<hr>
<p>下面分别从iOS、pig、oozie中总结一下date类型关于时区的处理。  </p>
<h4 id="iOS中的时区问题"><a href="#iOS中的时区问题" class="headerlink" title="iOS中的时区问题"></a>iOS中的时区问题</h4><p>在iOS中，从iOS4.1开始，<code>[NSDate date]</code>方法获取的当前时间是0时区的时间，即比北京时间晚8个小时(倒流8个小时，原本北京时间是20:00，但0时区是12:00)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSDate *date1 = [NSDate date];</div><div class="line">NSString *date2Str = @&quot;2016-08-17 20:15&quot;;</div><div class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init];</div><div class="line">[dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm&quot;];</div><div class="line">NSDate *date2 = [dateFormatter dateFromString:date2Str];</div><div class="line"></div><div class="line">NSLog(@&quot;date1:%@&quot;, [dateFormatter stringFromDate:date1]);</div><div class="line">NSLog(@&quot;date2:%@&quot;, [dateFormatter stringFromDate:date2]);</div></pre></td></tr></table></figure></p>
<p>比如当前时间是20:15，则在第date1代码处打断点，查看到时间如下:<br><img src="http://oc5u7idl7.bkt.clouddn.com/date1.png" alt="date1">  </p>
<p>然而，用NSDateFormatter对象转换成字符串，打印出来的时间却是当前时间:<br><img src="http://oc5u7idl7.bkt.clouddn.com/date1Formatter.png" alt="date1Log">    </p>
<p>所以，在iOS中，NSDateFormatter对象在对时间格式化的时候，已经处理了时区问题。具体来说，NSDateFormatter是将NSDate的0时区处理成当前时区，然后才转化成时间字符串。反过来，如果有一个时间字符串，要通过NSDateFormatter转换成NSDate类型，那么NSDateFormatter也会把时间处理成0时区的时间，如下图:<br><img src="http://oc5u7idl7.bkt.clouddn.com/date2.png" alt="date2">  </p>
<p>可见，在iOS中，时区问题被NSDateFormatter对象隐藏了.若不涉及到日历、本地通知等操作，程序员也不需要考虑时区。但是，并不是所有的NSDate都是用NSDateFormatter来处理的。可能遇到意想不到的两个时区的时间比较。这样如果要把其中一个时间修改为当前时区的时间，则可以用如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSDate *)currentLocalDate&#123;</div><div class="line">    NSDate *date = [NSDate date];</div><div class="line">    NSTimeZone *zone = [NSTimeZone systemTimeZone];</div><div class="line">    NSInteger interval = [zone secondsFromGMTForDate:date];</div><div class="line">    NSDate *localDate = [date dateByAddingTimeInterval:interval];</div><div class="line">    return localDate;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="pig中的时区问题"><a href="#pig中的时区问题" class="headerlink" title="pig中的时区问题"></a>pig中的时区问题</h4><p>在pig抽取数据的时候，记得一次使用<code>value.fields.data#&#39;timestamp&#39; as timestamp:long</code>,获取日志中的时间，然后用<code>UnixToISO(timestamp) as ISOTime</code>进行时间戳的转换，发现得到的结果有很多发生在凌晨2点到5点。后来发现是时区的问题，本身日志应该是在上午10点、11点的。这个目前还不太清楚是什么原因，可能也是环境搭建的问题，回头有精力再深究吧。如果哪位高手知道原因，希望能交流一下，不胜感激。  </p>
<h4 id="oozie的时区问题"><a href="#oozie的时区问题" class="headerlink" title="oozie的时区问题"></a>oozie的时区问题</h4><p>在oozie启动定时任务的时候，时区问题就更加重要了。但是oozie的时区问题比较棘手，也不知道是因为环境搭建的问题，还是其它原因，我在部署oozie任务时，还要考虑8个小时的时差。（感觉环境搭建好麻烦啊，深刻理解运维人员的辛苦……）  </p>
<p>因此，在coordinator中，打算7月26日凌晨4点跑的任务，在<code>coordinator-app</code>的<code>start</code>属性就要设置成<code>2016-07-25T20:00Z</code>，如果本身就是处理头一天的数据（即7月25日），并且输出结果的路径按日期进行拼接，则在<code>coordinator.xml</code>的<code>action</code>中就可以指定<code>workflow.xml</code>的路径，同时把日期以变量的形式传入<code>workflow.xml</code>，具体如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">workflow</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">app-path</span>&gt;</span>$&#123;wf_app_path&#125;<span class="tag">&lt;/<span class="name">app-path</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>analysisDate<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;coord:formatTime(coord:nominalTime(),'yyyy-MM-dd')&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">workflow</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>很多时候，因为时区问题会让处理变得比较麻烦，需要灵活使用oozie的EL常量。如下：<br><code>&lt;value&gt;${coord:formatTime(coord:dateOffset(coord:nominalTime(), -1, &#39;DAY&#39;), &#39;yyyy-MM-dd&#39;)}&lt;/value&gt;</code></p>
<h4 id="XML-Schema日期时间"><a href="#XML-Schema日期时间" class="headerlink" title="XML Schema日期时间"></a>XML Schema日期时间</h4><p>有时候经常看到打印的结果是这种格式：<code>2002-05-30T09:30:10Z</code>， 有日期，有时间没问题。那么其中的<strong>T</strong>和<strong>Z</strong>代表什么含义呢？<br>这其实是标准XML Schema的日期时间数据格式。其具体的格式是这样的：<br><code>&quot;YYYY-MM-DDThh:mm:ss&quot;</code> </p>
<ul>
<li><code>YYYY</code> 表示年份</li>
<li><code>MM</code> 表示月份</li>
<li><code>DD</code> 表示日</li>
<li><code>T</code> 表示必需的时间部分的起始</li>
<li><code>hh</code> 表示小时</li>
<li><code>mm</code> 表示分钟</li>
<li><code>ss</code> 表示秒  </li>
</ul>
<p>比如：<code>&lt;startdate&gt;2002-05-30T09:00:00&lt;/startdate&gt;</code><br>在日期或时间的结果加<strong>Z</strong>表示时区<code>(TimeZone)</code>，如果单纯一个Z，表示使用世界协调时间(UTC)，默认的是0时区。当然，也可以通过在时间后添加一个正的或负时间的方法，来规定以世界调整时间为准的偏移量。比如这样：<br><code>&lt;start&gt;09:30:10+06:00&lt;/start&gt;</code><br><code>&lt;start&gt;09:30:10-06:00&lt;/start&gt;</code></p>
<p>先写到这里吧，有更多实践的时候再补充。  </p>
<blockquote>
<p>如果本文有出于我个人理解或表达的错误，还望指正。<br>如果本文有涉及到版权、知识产权的问题，请及时与我联系。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的抽象类和接口]]></title>
      <url>https://FergusChen.github.io/2016/08/16/Java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>写这篇文章，是想从面向对象设计的角度出发，去探讨抽象类和接口。也是对抽象类和接口要点的总结。<br><a id="more"></a></p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>我们知道，抽象是面向对象的四大特性之一。我们从现实世界的事物中可以抽象出事物的属性和功能。通过分析不同的事物，发现彼此之间可能存在很多不同的关系，比如层次的继承关系、部分与整体强相关的组合关系、部分与整体弱相关的聚合关系等等。其中，将事物的共性（属性和方法）抽取出来，就形成父子继承关系。在这个过程中，有些方法是有默认实现的，就可以在父类中定义方法体（尽管子类可以覆盖）。但有些只知道有此方法，根本不知道子类会如何实现。这时候，抽象类就派上用场了。<code>注意：抽象类描述的仍是继承关系。</code>  </p>
<p>抽象类用于定义所有子类共同的、但不确定如何实现的成员方法。Java中抽象类的使用有如下要点：</p>
<ul>
<li>抽象方法必须定义在抽象类中；</li>
<li>抽象类和抽象方法都必须被abstract关键字修饰；</li>
<li>抽象类不能被初始化。解释的话，知乎上的一个回复也很贴切：周星驰的电影中那个去水果店，揪住老板说要一斤水果！老板问他你要什么水果，他说他就要水果！这个水果就是抽象类，你如果能在水果店买到一斤叫水果的水果，那就能实例化一个抽象类。</li>
<li>抽象类的方法必须在子类中被覆盖才能使用；</li>
<li>抽象类中既可以有抽象方法，也可以定义具体的成员变量和成员方法。除了具有抽象方法之外，其它的跟普通类一样定义；</li>
<li>一旦子类继承了某个抽象类，则抽象类中的抽象方法必须在子类中被覆盖；</li>
<li>若某个类要继承抽象类，同样使用<strong>extends</strong>关键字，而且是单继承。即一个类只能继承一个抽象类。  </li>
</ul>
<p>一个抽象类的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"my name:"</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口是对外暴露的一系列方法的声明，用于对类进行扩展。接口的本质是一系列规范，<code>在Objective-C中甚至没有接口（Interface），而是叫协议（protocol）</code>。理解这一点，就好像主板上对外提供各种接口，有USB接口、SATA硬盘接口、PCIE接口等。尽管不同的主板可以将接口的颜色换一下，位置换一下。但是各类接口的尺寸、针脚等都是固定的，是早先定义的规范。  </p>
<p>在面向对象设计中，接口就是预先定义的规范。当定义了一个接口，仅仅说明了此接口能<strong>做什么</strong>，没有定义<strong>如何做</strong>。如果一个类实现此接口，就立刻知道了这个类能<strong>做什么</strong>，至于<strong>如何做</strong>，是在类内部定义的。</p>
<p>Java中接口用得非常广泛，比如<strong>Comparable接口</strong>定义的规范是：两个对象可以比较。但如何比较取决于对象内部的实现。比较String和Number都不是问题，但比较两个自定义对象时，是按照哪个字段进行比较，就要在类内部实现了。如Student类可以按照姓名比较，也可以按照学号比较等。  </p>
<p>Java中接口的使用有如下要点：  </p>
<ul>
<li>接口是用于对类进行扩展的。若某个类实现了一个接口，就证明该类具有此接口定义的所有方法。</li>
<li>接口中可以定义两类元素：常量和抽象方法；<code>注意：接口中的方法都是public的。</code></li>
<li>接口中的常量默认都是public static final的。尽管如此，显式声明可以提高代码可读性；</li>
<li>接口中的方法默认都是public abstract的，尽量显式声明；</li>
<li>接口不能被初始化，但可以通过接口名调用接口中的常量；</li>
<li>java中支持多实现。即一个类可以实现多个接口。</li>
<li>若某个类要实现接口，使用<strong>implements</strong>关键字。    </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Pocket</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SIZE = <span class="number">20</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getSome</span><span class="params">()</span></span>;</div><div class="line">    <span class="keyword">int</span> MAX_COUNT = <span class="number">5</span>; <span class="comment">//合法，但不友好，尽量添加public static final修饰</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pubSome</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，接口也可以被继承，但只能被接口继承，甚至可以在接口之间实现多继承。因为接口中的方法只是声明，而具体的实现是在实现此接口的类中。若两个接口中有签名完全相同的方法，一个类实现了这两个接口，只要将接口中声明的这个方法实现了就行，无所谓这个方法是来自哪个接口。<code>注意，不要在不同的接口定义方法名和参数列表都相同，但返回值不相同的方法，这样的设计很糟糕。</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showA</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showB</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;  <span class="comment">//必须实现接口A和接口B的所有方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showA</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showB</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="抽象类和接口的比较"><a href="#抽象类和接口的比较" class="headerlink" title="抽象类和接口的比较"></a>抽象类和接口的比较</h4><p>具体使用要点的比较就不多说了，上面都有。  </p>
<p>不过，有的人觉得既然抽象类已经可以定义抽象方法，类可以继承并实现此方法。接口也是定义抽象方法的，而且接口还不能定义成员变量和有实现的成员方法，比抽象类的功能还弱。为什么有抽象类了还需要接口呢？就说接口可以多实现，抽象类只能单继承，但如果Java某一天支持多继承了，是不是接口就没有存在的意义了呢？  </p>
<p>其实，这样的问题只是从两者功能实现的相似性考虑问题了。然而，看到本质，还是面向对象设计思想。抽象类描述的是<strong>继承</strong>的关系，而接口则是对类的扩展，可以描述<strong>聚合</strong>或<strong>组合</strong>的关系。这个是有很大区别的。比如知乎的鱼鱼鱼举的一个例子就很贴切：</p>
<blockquote>
<p>苹果和鸡都可以吃，但是苹果是水果，鸡是动物，这个时候可以通过实现 edible 这个接口。所以说，“接口比类带来更多的灵活性”。   </p>
</blockquote>
<p>尽管实际开发中很多功能两者都可以实现，但是良好的实现是取决于良好的面向对象设计思想。这一点也很重要。  </p>
<p>如果对于抽象类和接口比较迷糊，可以到知乎的一个问题上看看，瞬间会清晰很多。<a href="https://www.zhihu.com/question/20111251" target="_blank" rel="external">Java 中的接口有什么作用？</a>   </p>
<p>若感觉文章中有什么问题，欢迎一起讨论，或者可以帮我指正。非常感谢~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java中的继承]]></title>
      <url>https://FergusChen.github.io/2016/08/14/java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p><strong>继承</strong>是面向对象设计的四大特性之一。从表面上看，继承关系就是“父子”关系。子类可以继承父类非私有的成员变量和成员方法。换句话说，在父类中已经定义的成员变量和成员方法，子类可以直接使用，而不必重新定义。那么，在java中，继承是如何体现的呢？在使用继承关系时，又有哪些要点呢？在这篇文章就简单总结一下。<a id="more"></a>  </p>
<hr>
<p>首先说继承。如果仅仅说继承就是“父子”关系，其实不太全面。准确来说，继承描述的是对象之间的<strong> “is a” </strong>关系。 举例来说：学生是一个人；牡丹是一种花；鹦鹉是一种鸟…… 这样的关系简直是太常见了。  </p>
<p>在java中实现继承可以更清楚地展现类之间的关系，易于维护。这也是面向对象设计的优点。同时，继承可以提高代码的复用性，提高项目的可扩展性等等。<code>注意：一定不能为了复用代码而随便继承。</code>代码实现是基于设计的，没有“is a”关系的类，就不要建立继承关系。</p>
<hr>
<p>java中继承用<strong>extends</strong>关键字。子类中可以直接使用父类的成员变量和成员方法，同时也可以重新定义成员变量和成员方法（<em>覆盖</em>）。在子类中，关键字<strong>this</strong>指向当前的类，关键字<strong>super</strong>指向父类。如下：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"my name:"</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line">    String university;</div><div class="line">    <span class="comment">//覆盖父类的成员方法</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.speak();</div><div class="line">        System.out.println(<span class="string">"my university:"</span>+ <span class="keyword">this</span>.university);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"I should study hard, because it's my duty"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"I should work hard, because it's my duty"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="成员变量的继承"><a href="#成员变量的继承" class="headerlink" title="成员变量的继承"></a>成员变量的继承</h3><p>子类可以继承父类非私有的成员变量，也可以在子类中覆盖父类的成员变量。在子类中，使用this调用子类的成员变量，使用super调用父类的成员变量。  </p>
<h3 id="成员方法的继承"><a href="#成员方法的继承" class="headerlink" title="成员方法的继承"></a>成员方法的继承</h3><p>子类可以继承父类非私有的成员方法。同时子类可以覆盖父类的成员方法（如上例Student类中是speak方法）。继承中的这个特性让项目更易于扩展。具体来说，就是项目中同样的方法需要有新的实现时（<em>比如：来电显示中以前只显示号码和姓名，现在要添加归属地和头像的显示；播放视频时以前只是单纯地播放，现在要在视频右上角显示当前时间等等。需求变更、添加功能是很常见的</em>）。若项目已经上线，或进入后期阶段，则直接修改原来的父类或子类的代码，将是一个灾难。因为可能很多地方都用到了这个类，要改的话，可能会改一堆……<br>所以，最好的办法就是使用继承，并在新类中覆盖需要重写的方法。在重写该方法时，可以用super调用父类的方法，在此基础上扩展新功能。以后只需要new新类，就可以调用新的功能。<br>当然，若要覆盖父类的成员方法，需要以下两个条件：</p>
<ol>
<li>子类中，该方法的访问权限要大于或等于父类的方法。我们知道java中访问权限有4种：<strong>public、private、protected和default</strong>。上个例子中没有任何修饰符，就是default权限。<strong>default</strong>的访问级别介于public和private之间。若父类中是default权限，子类只能是default、protected或public，不能是private。<code>注意：如果是父类中有个A方法是private修饰的，那么，在子类中就算有一个方法与A方法签名完全相同，也不算方法覆盖，而是子类中的新方法。</code>因为在子类，该方法本身不可见。这里，覆盖的说法没意义。</li>
<li>静态方法只能覆盖静态方法，不能覆盖非静态方法。因为静态和非静态的加载时机不一样，存储位置也不一样。静态的成员变量和成员方法都是类加载的时候就加载进入内存，而非静态是创建对象时加载。  </li>
</ol>
<h3 id="继承中的构造方法"><a href="#继承中的构造方法" class="headerlink" title="继承中的构造方法"></a>继承中的构造方法</h3><p>构造方法和类同名，当然没有继承的说法。但是，在继承中，构造方法的调用时机需要说明一下。<br><strong>子类的所有构造方法，都会先执行父类的默认构造方法，然后才执行子类构造方法中的其它语句。</strong>也就是说，在子类的构造方法中都会隐式地插入这样一句代码：<code>super();</code>（子类构造方法中先用<code>this()</code>调用其它构造方法的除外，因为在<code>this()</code>中已经调用了父类的构造方法）<br>因为在子类其实包含父类的成员变量，但这些成员变量的初始化是在父类中定义的。因此，初始化子类时一定要先调用父类的构造方法初始化这些成员变量。<br>当然，子类的构造方法中也可以手动指定调用父类的哪个构造方法，但一定要先调用父类的构造方法。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>说了这么多，继承的确有很多好处，但是继承却破坏了对象的封装性。在java中，为了解决这个问题，可以使用final关键字。<br>final关键字可以修饰类、变量、方法等，只要被final修饰，就不能再被修改。具体来说，final修饰的类不能被继承；final修饰的方法不能被覆盖；final修饰的变量就是一个常量了。<strong>ps：</strong>可以在类中定义全局静态常量，用类名就可以直接访问，如下：<code>public static final double PI = 3.14159;</code></p>
<p>好了，先记这些吧，以后有新的见解再补上。</p>
<p>若文章中有问题，欢迎指正。</p>
]]></content>
    </entry>
    
  
  
</search>
